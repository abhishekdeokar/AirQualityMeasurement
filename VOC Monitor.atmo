{
  "name": "VOC Monitor",
  "createVersion": "2017-08-12",
  "description": "An application to monitor air quality and CO2 levels around you.\nIt will alert if air quality or CO2 levels not good for you.\nIdeally expected to be installed at multiple locations tha expect heavy footfall, like grocery stores, shopping complexes, etc..\n\nIt can send collected data to your phone/tablet and cloud, so you can use them to view air quality analytics over time.\n",
  "lastModified": "2019-03-05T00:39:19.386Z",
  "created": "2019-02-19T00:39:19.386Z",
  "meta": {
    "projectTypeName": "NXP Rapid IoT",
    "projectTypeId": "NxpRpk"
  },
  "planes": {
    "NXP Rapid IoT": {
      "type": "mcuxpresso",
      "compilerVersion": "latest",
      "variants": [
        "NxpRpk"
      ],
      "meta": {},
      "elements": [
        {
          "name": "AirQualityCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), ATMO_PROPERTY(AirQualityCharacteristic, readDataType), ATMO_PROPERTY(AirQualityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AirQualityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AirQualityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": true,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e75-a4ff-6f0cd50005f9",
            "read": true,
            "write": true,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 450.50006103515625,
            "editorY": 290,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "SX9500Touch",
          "type": "EmbeddedSX9500",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(SX9500Touch, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(SX9500Touch, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(SX9500Touch, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(SX9500Touch, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(SX9500Touch, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(SX9500Touch, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(SX9500Touch, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(SX9500Touch, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(SX9500Touch, pressRight));\n\treturn ATMO_Status_Success;",
              "getTouchData": "",
              "pressUp": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressDown": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressLeft": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressRight": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "getTouchData": false,
              "pressUp": false,
              "pressDown": false,
              "pressLeft": false,
              "pressRight": false
            },
            "i2cInstance": 1,
            "gpioInstance": 0,
            "interruptEnabled": true,
            "interruptGpio": "PTA9",
            "i2cAddress": "0x28"
          },
          "meta": {
            "editorX": 1051.33349609375,
            "editorY": 39,
            "lastTrigger": "rightPressed"
          },
          "triggers": {
            "triggered": [],
            "touchDataRead": [],
            "upPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateUp"
              }
            ],
            "downPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateDown"
              }
            ],
            "leftPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateLeft"
              }
            ],
            "rightPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateRight"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "getTouchData": false,
            "pressUp": false,
            "pressDown": false,
            "pressLeft": false,
            "pressRight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "getTouchData",
              "triggers": [
                "touchDataRead"
              ]
            },
            {
              "name": "pressUp",
              "triggers": [
                "upPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressDown",
              "triggers": [
                "downPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressLeft",
              "triggers": [
                "leftPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressRight",
              "triggers": [
                "rightPressed",
                "touchDataRead"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedPageController",
          "type": "EmbeddedPageController",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_UI_PAGE_CONTROLLER_Config_t config;\n\tconfig.enableUpDownNavLabels = ATMO_PROPERTY(EmbeddedPageController, upDownNavigationLabelsEnabled);\n\tconfig.enableLeftRightNavLabels = ATMO_PROPERTY(EmbeddedPageController, leftRightNavigationLabelsEnabled);\n\tATMO_UI_Page_SetConfiguration(&config);\n    return ATMO_Status_Success;\n\t",
              "displayRootPage": "\n\t\n\tATMO_UI_Page_DisplayRootPage();\n\treturn ATMO_Status_Success;\n\t",
              "navigateUp": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_UP);\n\treturn ATMO_Status_Success;\n\t",
              "navigateDown": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_DOWN);\n\treturn ATMO_Status_Success;\n\t",
              "navigateLeft": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_LEFT);\n\treturn ATMO_Status_Success;\n\t",
              "navigateRight": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_RIGHT);\n\treturn ATMO_Status_Success;\n\t",
              "processTopRightButton": "\n\tATMO_UI_Page_ProcessUserButton(1);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomRightButton": "\n\tATMO_UI_Page_ProcessUserButton(2);\n\treturn ATMO_Status_Success;\n\t",
              "processTopLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(3);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(4);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "displayRootPage": false,
              "navigateUp": false,
              "navigateDown": false,
              "navigateLeft": false,
              "navigateRight": false,
              "processTopRightButton": false,
              "processBottomRightButton": false,
              "processTopLeftButton": false,
              "processBottomLeftButton": false
            },
            "upDownNavigationLabelsEnabled": true,
            "leftRightNavigationLabelsEnabled": true
          },
          "meta": {
            "editorX": 1250.33349609375,
            "editorY": 41,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "navigateUp": [],
            "navigateDown": [],
            "navigateLeft": [],
            "navigateRight": [],
            "processTopRightButton": [],
            "processBottomRightButton": [],
            "processTopLeftButton": [],
            "processBottomLeftButton": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "displayRootPage": false,
            "navigateUp": false,
            "navigateDown": false,
            "navigateLeft": false,
            "navigateRight": false,
            "processTopRightButton": false,
            "processBottomRightButton": false,
            "processTopLeftButton": false,
            "processBottomLeftButton": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "displayRootPage",
              "triggers": []
            },
            {
              "name": "navigateUp",
              "triggers": [
                "navigateUp"
              ]
            },
            {
              "name": "navigateDown",
              "triggers": [
                "navigateDown"
              ]
            },
            {
              "name": "navigateLeft",
              "triggers": [
                "navigateLeft"
              ]
            },
            {
              "name": "navigateRight",
              "triggers": [
                "navigateRight"
              ]
            },
            {
              "name": "processTopRightButton",
              "triggers": [
                "processTopRightButton"
              ]
            },
            {
              "name": "processBottomRightButton",
              "triggers": [
                "processBottomRightButton"
              ]
            },
            {
              "name": "processTopLeftButton",
              "triggers": [
                "processTopLeftButton"
              ]
            },
            {
              "name": "processBottomLeftButton",
              "triggers": [
                "processBottomLeftButton"
              ]
            }
          ]
        },
        {
          "name": "AirQuality_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(AirQuality_Pag, x), ATMO_PROPERTY(AirQuality_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(AirQuality_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(AirQuality_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(AirQuality_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(AirQuality_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(AirQuality_Pag, topLeftButtonEnabled), ATMO_PROPERTY(AirQuality_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(AirQuality_Pag, x);\n    config.x = ATMO_PROPERTY(AirQuality_Pag, x);\n    config.y = ATMO_PROPERTY(AirQuality_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(AirQuality_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(AirQuality_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(AirQuality_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(AirQuality_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(AirQuality_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(AirQuality_Pag, spanY);\n    config.title = ATMO_PROPERTY(AirQuality_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(AirQuality_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(AirQuality_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(AirQuality_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(AirQuality_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), ATMO_ABILITY(AirQuality_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 1, ATMO_ABILITY(AirQuality_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 2, ATMO_ABILITY(AirQuality_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 3, ATMO_ABILITY(AirQuality_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 4, ATMO_ABILITY(AirQuality_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(AirQuality_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(AirQuality_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Air TVOC",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "4",
            "y": 0,
            "spanX": "1",
            "spanY": 1,
            "icon": "icon_applications_airq",
            "label": ""
          },
          "meta": {
            "editorX": 651.1666870117188,
            "editorY": 40,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "Interval",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval, instance), \n\t\tATMO_ABILITY(Interval, interval), \n\t\tATMO_PROPERTY(Interval, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1",
            "time": "10000"
          },
          "meta": {
            "editorX": 51.16668701171875,
            "editorY": 341,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CCS811AirQuality",
                "targetAbility": "readTVOC"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CCS811AirQuality1",
                "targetAbility": "readCO2"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "GetAirQualityStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tint temp = 0;\n\tATMO_GetInt(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%d ppb\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 450.3333740234375,
            "editorY": 37,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQuality_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "CCS811AirQuality",
          "type": "EmbeddedCCS811",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(CCS811AirQuality, operatingMode);\n\tconfig.address = ATMO_PROPERTY(CCS811AirQuality, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(CCS811AirQuality, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTVOC": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readCO2": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTVOC": false,
              "readCO2": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x5A",
            "operatingMode": "1"
          },
          "meta": {
            "editorX": 200.3333740234375,
            "editorY": 137,
            "lastTrigger": "TVOCRead"
          },
          "triggers": {
            "triggered": [],
            "TVOCRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQualityCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetAirQualityStr",
                "targetAbility": "trigger"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedComparison1",
                "targetAbility": "evaluate"
              }
            ],
            "CO2Read": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTVOC": false,
            "readCO2": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTVOC",
              "triggers": [
                "TVOCRead"
              ]
            },
            {
              "name": "readCO2",
              "triggers": [
                "CO2Read"
              ]
            }
          ]
        },
        {
          "name": "GetCO2Str",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tint temp = 0;\n\tATMO_GetInt(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%d ppb\", temp);\n\tATMO_CreateValueString(out, str);"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 450.3333740234375,
            "editorY": 439,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CO2_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "CCS811AirQuality1",
          "type": "EmbeddedCCS811",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(CCS811AirQuality1, operatingMode);\n\tconfig.address = ATMO_PROPERTY(CCS811AirQuality1, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(CCS811AirQuality1, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTVOC": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readCO2": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTVOC": false,
              "readCO2": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x5A",
            "operatingMode": "1"
          },
          "meta": {
            "editorX": 201.3333740234375,
            "editorY": 591,
            "lastTrigger": "CO2Read"
          },
          "triggers": {
            "triggered": [],
            "TVOCRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetCO2Str",
                "targetAbility": "trigger"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CO2Characteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedComparison",
                "targetAbility": "evaluate"
              }
            ],
            "CO2Read": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetCO2Str",
                "targetAbility": "trigger"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CO2Characteristic",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTVOC": false,
            "readCO2": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTVOC",
              "triggers": [
                "TVOCRead"
              ]
            },
            {
              "name": "readCO2",
              "triggers": [
                "CO2Read"
              ]
            }
          ]
        },
        {
          "name": "CO2_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(CO2_Pag, x), ATMO_PROPERTY(CO2_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(CO2_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(CO2_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(CO2_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(CO2_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(CO2_Pag, topLeftButtonEnabled), ATMO_PROPERTY(CO2_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(CO2_Pag, x);\n    config.x = ATMO_PROPERTY(CO2_Pag, x);\n    config.y = ATMO_PROPERTY(CO2_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(CO2_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(CO2_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(CO2_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(CO2_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(CO2_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(CO2_Pag, spanY);\n    config.title = ATMO_PROPERTY(CO2_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(CO2_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(CO2_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(CO2_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(CO2_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(CO2_Pag,pageHandle), ATMO_ABILITY(CO2_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(CO2_Pag,pageHandle), 1, ATMO_ABILITY(CO2_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(CO2_Pag,pageHandle), 2, ATMO_ABILITY(CO2_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(CO2_Pag,pageHandle), 3, ATMO_ABILITY(CO2_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(CO2_Pag,pageHandle), 4, ATMO_ABILITY(CO2_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(CO2_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(CO2_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "displayPage": false,
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "CO2 Level",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "5",
            "y": 0,
            "spanX": "1",
            "spanY": 1,
            "icon": "icon_applications_airq",
            "label": "\"n/a\""
          },
          "meta": {
            "editorX": 601.1666870117188,
            "editorY": 440,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "CO2Characteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\t&ATMO_VARIABLE(CO2Characteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(CO2Characteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(CO2Characteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(CO2Characteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(CO2Characteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(CO2Characteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(CO2Characteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(CO2Characteristic, writeDataType), ATMO_PROPERTY(CO2Characteristic, readDataType), ATMO_PROPERTY(CO2Characteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\t&ATMO_VARIABLE(CO2Characteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(CO2Characteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(CO2Characteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\tATMO_VARIABLE(CO2Characteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(CO2Characteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(CO2Characteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\tATMO_VARIABLE(CO2Characteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(CO2Characteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "0fa3c9f1-96a2-4d4c-b149-8d764a904a8f",
            "bleCharacteristicUuid": "0fa3c9f1-96a2-4d4c-b149-8d764a904a90",
            "read": true,
            "write": true,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 451.50006103515625,
            "editorY": 692,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkUserButtons",
          "type": "EmbeddedNxpRpkUserButtons",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    ATMO_MK64F_GPIO_EnableResetCombo(ATMO_PROPERTY(EmbeddedNxpRpkUserButtons, enableResetCombo));\n    ATMO_MK64F_GPIO_EnableDisplayToggleCombo(ATMO_PROPERTY(EmbeddedNxpRpkUserButtons, enableDisplayToggleCombo));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW1_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, topRightPushed));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW2_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, bottomRightPushed));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW3_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, topLeftPushed));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW4_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, bottomLeftPushed));\n\treturn ATMO_Status_Success;\n\t",
              "topRightPushed": "\n\treturn ATMO_Status_Success;\n    ",
              "bottomRightPushed": "\n\treturn ATMO_Status_Success;\n    ",
              "topLeftPushed": "\n\treturn ATMO_Status_Success;\n    ",
              "bottomLeftPushed": "\n\treturn ATMO_Status_Success;\n    "
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "topRightPushed": false,
              "bottomRightPushed": false,
              "topLeftPushed": false,
              "bottomLeftPushed": false
            },
            "enableResetCombo": true,
            "enableDisplayToggleCombo": true
          },
          "meta": {
            "editorX": 1051.33349609375,
            "editorY": 141,
            "lastTrigger": "bottomLeftPushed"
          },
          "triggers": {
            "triggered": [],
            "topRightPushed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightHigh"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Interval1",
                "targetAbility": "trigger"
              }
            ],
            "bottomRightPushed": [],
            "topLeftPushed": [],
            "bottomLeftPushed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "topRightPushed": false,
            "bottomRightPushed": false,
            "topLeftPushed": false,
            "bottomLeftPushed": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "topRightPushed",
              "triggers": [
                "topRightPushed"
              ]
            },
            {
              "name": "bottomRightPushed",
              "triggers": [
                "bottomRightPushed"
              ]
            },
            {
              "name": "topLeftPushed",
              "triggers": [
                "topLeftPushed"
              ]
            },
            {
              "name": "bottomLeftPushed",
              "triggers": [
                "bottomLeftPushed"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkBacklight",
          "type": "EmbeddedNxpRpkBacklight",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    Backlight_SetLevel(ATMO_PROPERTY(EmbeddedNxpRpkBacklight, initialSetting));\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightOff": "\n    Backlight_SetLevel(BLIGHT_LEVEL_OFF);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightLow": "\n    Backlight_SetLevel(BLIGHT_LEVEL_LOW);\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightMedium": "\n    Backlight_SetLevel(BLIGHT_LEVEL_MEDIUM);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightHigh": "\n    Backlight_SetLevel(BLIGHT_LEVEL_HIGH);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setBacklightOff": false,
              "setBacklightLow": false,
              "setBacklightMedium": false,
              "setBacklightHigh": false
            },
            "initialSetting": "BLIGHT_LEVEL_LOW"
          },
          "meta": {
            "editorX": 1253.33349609375,
            "editorY": 142,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "backlightSet": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setBacklightOff": false,
            "setBacklightLow": false,
            "setBacklightMedium": false,
            "setBacklightHigh": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setBacklightOff",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightLow",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightMedium",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightHigh",
              "triggers": [
                "backlightSet"
              ]
            }
          ]
        },
        {
          "name": "Interval1",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval1, instance), \n\t\tATMO_ABILITY(Interval1, interval), \n\t\tATMO_PROPERTY(Interval1, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1",
            "time": "20000"
          },
          "meta": {
            "editorX": 1151.33349609375,
            "editorY": 240,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightOff"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedComparison",
          "type": "EmbeddedComparison",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\treturn ATMO_Status_Success;\n\t",
              "evaluate": "\n\tbool conditionTrue = false;\n\n\t// Convert property to same type as input\n\tATMO_Value_t targetStr;\n\tATMO_Value_t targetNum;\n\t\n\tATMO_InitValue(&targetStr);\n\tATMO_InitValue(&targetNum);\n\tATMO_CreateValueString(&targetStr, ATMO_PROPERTY(EmbeddedComparison, target));\n\tATMO_CreateValueConverted(&targetNum, in->type, &targetStr);\n\t\n\tif(ATMO_CompareValues(in, &targetNum, ATMO_PROPERTY(EmbeddedComparison, condition), &conditionTrue) != ATMO_Status_Success)\n\t{\n\t\tATMO_Value_t value;\n\t\tATMO_InitValue(&value);\n\t\tATMO_TriggerHandler(ATMO_TRIGGER(EmbeddedComparison, invalidType), NULL);\n\t\tATMO_FreeValue(&value);\n\t\tATMO_FreeValue(&targetStr);\n\t\tATMO_FreeValue(&targetNum);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_FreeValue(&targetStr);\n\tATMO_FreeValue(&targetNum);\n\n\tif(conditionTrue)\n\t{\n\t\tATMO_Value_t value;\n\t\tATMO_InitValue(&value);\n\t\tATMO_TriggerHandler(ATMO_TRIGGER(EmbeddedComparison, conditionTrue), NULL);\n\t\tATMO_FreeValue(&value);\t\t\n\t}\n\telse\n\t{\n\t\tATMO_Value_t value;\n\t\tATMO_InitValue(&value);\n\t\tATMO_TriggerHandler(ATMO_TRIGGER(EmbeddedComparison, conditionFalse), NULL);\n\t\tATMO_FreeValue(&value);\t\t\t\n\t}\n\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {
              "target": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "evaluate": false
            },
            "condition": "ATMO_GREATER_THAN",
            "target": "1000"
          },
          "meta": {
            "editorX": 451.3333740234375,
            "editorY": 592,
            "lastTrigger": "conditionTrue"
          },
          "triggers": {
            "triggered": [],
            "conditionTrue": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkRgbLed",
                "targetAbility": "setWhiteOn"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Interval2",
                "targetAbility": "trigger"
              }
            ],
            "conditionFalse": [],
            "invalidType": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "evaluate": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "evaluate",
              "triggers": []
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkRgbLed",
          "type": "EmbeddedNxpRpkRgbLed",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_BLACK);\n\treturn ATMO_Status_Success;\n\t",
              "setColorPreset": "\n    unsigned int desiredColor = 0;\n    ATMO_GetUnsignedInt(in, &desiredColor);\n\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(brightness, desiredColor);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessLow": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_LOW, color);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessOff": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_OFF, color);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessMedium": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_MEDIUM, color);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessHigh": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, color);\n    return ATMO_Status_Success;\n    ",
              "setRedOn": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_RED);\n\treturn ATMO_Status_Success;\n    ",
              "setGreenOn": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_GREEN);\n\treturn ATMO_Status_Success;\n    ",
              "setBlueOn": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_BLUE);\n\treturn ATMO_Status_Success;\n    ",
              "setWhiteOn": "\treturn ATMO_Status_Success;",
              "toggleRed": "\n\tuint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    if(brightness == RGB_LED_BRIGHT_OFF || color == RGB_LED_COLOR_BLACK)\n    {\n        brightness = RGB_LED_BRIGHT_HIGH;\n    }\n    else\n    {\n        brightness = RGB_LED_BRIGHT_OFF;\n    }\n\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_RED);\n    return ATMO_Status_Success;\n\t",
              "toggleGreen": "\n\tuint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    if(brightness == RGB_LED_BRIGHT_OFF || color == RGB_LED_COLOR_BLACK)\n    {\n        brightness = RGB_LED_BRIGHT_HIGH;\n    }\n    else\n    {\n        brightness = RGB_LED_BRIGHT_OFF;\n    }\n\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_GREEN);\n    return ATMO_Status_Success;\n\t",
              "toggleBlue": "\n\tuint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    if(brightness == RGB_LED_BRIGHT_OFF || color == RGB_LED_COLOR_BLACK)\n    {\n        brightness = RGB_LED_BRIGHT_HIGH;\n    }\n    else\n    {\n        brightness = RGB_LED_BRIGHT_OFF;\n    }\n\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_BLUE);\n    return ATMO_Status_Success;\n\t",
              "setOff": "\n    uint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_BLACK);\n\treturn ATMO_Status_Success;\n    ",
              "setColorHex": "\n    unsigned int color = 0;\n    ATMO_GetUnsignedInt(in, &color);\n    uint8_t red = (color >> 16) & 0xFF;\n    uint8_t green = (color >> 8) & 0xFF;\n    uint8_t blue = color & 0xFF;\n    Rgb_Led_Set_Colors(red, green, blue);  \n    ATMO_CreateValueUnsignedInt(out, color);\n\treturn ATMO_Status_Success;\n    "
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setColorPreset": false,
              "setBrightnessLow": false,
              "setBrightnessOff": false,
              "setBrightnessMedium": false,
              "setBrightnessHigh": false,
              "setRedOn": false,
              "setGreenOn": false,
              "setBlueOn": false,
              "setWhiteOn": false,
              "toggleRed": false,
              "toggleGreen": false,
              "toggleBlue": false,
              "setOff": false,
              "setColorHex": false
            }
          },
          "meta": {
            "editorX": 1051.3333740234375,
            "editorY": 592,
            "lastTrigger": "colorSet"
          },
          "triggers": {
            "triggered": [],
            "brightnessSet": [],
            "colorSet": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setColorPreset": false,
            "setBrightnessLow": false,
            "setBrightnessOff": false,
            "setBrightnessMedium": false,
            "setBrightnessHigh": false,
            "setRedOn": false,
            "setGreenOn": false,
            "setBlueOn": false,
            "setWhiteOn": false,
            "toggleRed": false,
            "toggleGreen": false,
            "toggleBlue": false,
            "setOff": false,
            "setColorHex": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setColorPreset",
              "triggers": []
            },
            {
              "name": "setBrightnessLow",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setBrightnessOff",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setBrightnessMedium",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setBrightnessHigh",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setRedOn",
              "triggers": []
            },
            {
              "name": "setGreenOn",
              "triggers": []
            },
            {
              "name": "setBlueOn",
              "triggers": []
            },
            {
              "name": "setWhiteOn",
              "triggers": []
            },
            {
              "name": "toggleRed",
              "triggers": []
            },
            {
              "name": "toggleGreen",
              "triggers": []
            },
            {
              "name": "toggleBlue",
              "triggers": []
            },
            {
              "name": "setOff",
              "triggers": []
            },
            {
              "name": "setColorHex",
              "triggers": [
                "colorSet"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedComparison1",
          "type": "EmbeddedComparison",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\treturn ATMO_Status_Success;\n\t",
              "evaluate": "\n\tbool conditionTrue = false;\n\n\t// Convert property to same type as input\n\tATMO_Value_t targetStr;\n\tATMO_Value_t targetNum;\n\t\n\tATMO_InitValue(&targetStr);\n\tATMO_InitValue(&targetNum);\n\tATMO_CreateValueString(&targetStr, ATMO_PROPERTY(EmbeddedComparison1, target));\n\tATMO_CreateValueConverted(&targetNum, in->type, &targetStr);\n\t\n\tif(ATMO_CompareValues(in, &targetNum, ATMO_PROPERTY(EmbeddedComparison1, condition), &conditionTrue) != ATMO_Status_Success)\n\t{\n\t\tATMO_Value_t value;\n\t\tATMO_InitValue(&value);\n\t\tATMO_TriggerHandler(ATMO_TRIGGER(EmbeddedComparison1, invalidType), NULL);\n\t\tATMO_FreeValue(&value);\n\t\tATMO_FreeValue(&targetStr);\n\t\tATMO_FreeValue(&targetNum);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_FreeValue(&targetStr);\n\tATMO_FreeValue(&targetNum);\n\n\tif(conditionTrue)\n\t{\n\t\tATMO_Value_t value;\n\t\tATMO_InitValue(&value);\n\t\tATMO_TriggerHandler(ATMO_TRIGGER(EmbeddedComparison1, conditionTrue), NULL);\n\t\tATMO_FreeValue(&value);\t\t\n\t}\n\telse\n\t{\n\t\tATMO_Value_t value;\n\t\tATMO_InitValue(&value);\n\t\tATMO_TriggerHandler(ATMO_TRIGGER(EmbeddedComparison1, conditionFalse), NULL);\n\t\tATMO_FreeValue(&value);\t\t\t\n\t}\n\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {
              "target": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "evaluate": false
            },
            "condition": "ATMO_GREATER_THAN",
            "target": "325"
          },
          "meta": {
            "editorX": 451.3333740234375,
            "editorY": 141,
            "lastTrigger": "conditionTrue"
          },
          "triggers": {
            "triggered": [],
            "conditionTrue": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkRgbLed1",
                "targetAbility": "setBlueOn"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Interval2",
                "targetAbility": "trigger"
              }
            ],
            "conditionFalse": [],
            "invalidType": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "evaluate": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "evaluate",
              "triggers": []
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkRgbLed1",
          "type": "EmbeddedNxpRpkRgbLed",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_BLACK);\n\treturn ATMO_Status_Success;\n\t",
              "setColorPreset": "\n    unsigned int desiredColor = 0;\n    ATMO_GetUnsignedInt(in, &desiredColor);\n\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(brightness, desiredColor);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessLow": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_LOW, color);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessOff": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_OFF, color);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessMedium": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_MEDIUM, color);\n    return ATMO_Status_Success;\n    ",
              "setBrightnessHigh": "\n    uint8_t brightness = 0;\n    uint8_t color = 0;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, color);\n    return ATMO_Status_Success;\n    ",
              "setRedOn": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_RED);\n\treturn ATMO_Status_Success;\n    ",
              "setGreenOn": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_GREEN);\n\treturn ATMO_Status_Success;\n    ",
              "setBlueOn": "\n    RGB_Led_Set_State(RGB_LED_BRIGHT_HIGH, RGB_LED_COLOR_BLUE);\n\treturn ATMO_Status_Success;\n    ",
              "setWhiteOn": "\treturn ATMO_Status_Success;",
              "toggleRed": "\n\tuint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    if(brightness == RGB_LED_BRIGHT_OFF || color == RGB_LED_COLOR_BLACK)\n    {\n        brightness = RGB_LED_BRIGHT_HIGH;\n    }\n    else\n    {\n        brightness = RGB_LED_BRIGHT_OFF;\n    }\n\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_RED);\n    return ATMO_Status_Success;\n\t",
              "toggleGreen": "\n\tuint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    if(brightness == RGB_LED_BRIGHT_OFF || color == RGB_LED_COLOR_BLACK)\n    {\n        brightness = RGB_LED_BRIGHT_HIGH;\n    }\n    else\n    {\n        brightness = RGB_LED_BRIGHT_OFF;\n    }\n\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_GREEN);\n    return ATMO_Status_Success;\n\t",
              "toggleBlue": "\n\tuint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    if(brightness == RGB_LED_BRIGHT_OFF || color == RGB_LED_COLOR_BLACK)\n    {\n        brightness = RGB_LED_BRIGHT_HIGH;\n    }\n    else\n    {\n        brightness = RGB_LED_BRIGHT_OFF;\n    }\n\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_BLUE);\n    return ATMO_Status_Success;\n\t",
              "setOff": "\n    uint8_t color, brightness;\n    RGB_Led_Get_State(&brightness, &color);\n    RGB_Led_Set_State(brightness, RGB_LED_COLOR_BLACK);\n\treturn ATMO_Status_Success;\n    ",
              "setColorHex": "\n    unsigned int color = 0;\n    ATMO_GetUnsignedInt(in, &color);\n    uint8_t red = (color >> 16) & 0xFF;\n    uint8_t green = (color >> 8) & 0xFF;\n    uint8_t blue = color & 0xFF;\n    Rgb_Led_Set_Colors(red, green, blue);  \n    ATMO_CreateValueUnsignedInt(out, color);\n\treturn ATMO_Status_Success;\n    "
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setColorPreset": false,
              "setBrightnessLow": false,
              "setBrightnessOff": false,
              "setBrightnessMedium": false,
              "setBrightnessHigh": false,
              "setRedOn": false,
              "setGreenOn": false,
              "setBlueOn": false,
              "setWhiteOn": false,
              "toggleRed": false,
              "toggleGreen": false,
              "toggleBlue": false,
              "setOff": false,
              "setColorHex": false
            }
          },
          "meta": {
            "editorX": 750.3333740234375,
            "editorY": 142,
            "lastTrigger": "colorSet"
          },
          "triggers": {
            "triggered": [],
            "brightnessSet": [],
            "colorSet": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setColorPreset": false,
            "setBrightnessLow": false,
            "setBrightnessOff": false,
            "setBrightnessMedium": false,
            "setBrightnessHigh": false,
            "setRedOn": false,
            "setGreenOn": false,
            "setBlueOn": false,
            "setWhiteOn": false,
            "toggleRed": false,
            "toggleGreen": false,
            "toggleBlue": false,
            "setOff": false,
            "setColorHex": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setColorPreset",
              "triggers": []
            },
            {
              "name": "setBrightnessLow",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setBrightnessOff",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setBrightnessMedium",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setBrightnessHigh",
              "triggers": [
                "brightnessSet"
              ]
            },
            {
              "name": "setRedOn",
              "triggers": []
            },
            {
              "name": "setGreenOn",
              "triggers": []
            },
            {
              "name": "setBlueOn",
              "triggers": []
            },
            {
              "name": "setWhiteOn",
              "triggers": []
            },
            {
              "name": "toggleRed",
              "triggers": []
            },
            {
              "name": "toggleGreen",
              "triggers": []
            },
            {
              "name": "toggleBlue",
              "triggers": []
            },
            {
              "name": "setOff",
              "triggers": []
            },
            {
              "name": "setColorHex",
              "triggers": [
                "colorSet"
              ]
            }
          ]
        },
        {
          "name": "Interval2",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval2, instance), \n\t\tATMO_ABILITY(Interval2, interval), \n\t\tATMO_PROPERTY(Interval2, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1",
            "time": "10000"
          },
          "meta": {
            "editorX": 851.3333740234375,
            "editorY": 342,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkRgbLed",
                "targetAbility": "setOff"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        }
      ],
      "libraries": {
        "sx9500": {
          "libName": "sx9500",
          "manufacturer": "Semtech",
          "description": "SX9500 Capacitive Touch Sensor",
          "type": "Touch Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "gpio"
          ],
          "elements": [
            {
              "name": "SX9500Touch",
              "type": "EmbeddedSX9500",
              "icon": "EmbeddedTouch.svg",
              "defaultAbility": "getTouchData",
              "defaultTrigger": "touchDataRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "code": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(undefined, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(undefined, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(undefined, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(undefined, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(undefined, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(undefined, pressRight));\n\treturn ATMO_Status_Success;"
                },
                {
                  "name": "getTouchData",
                  "triggers": [
                    "touchDataRead"
                  ],
                  "code": ""
                },
                {
                  "name": "pressUp",
                  "triggers": [
                    "upPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressDown",
                  "triggers": [
                    "downPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressLeft",
                  "triggers": [
                    "leftPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressRight",
                  "triggers": [
                    "rightPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interruptEnabled",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "interruptGpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x28"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedSX9500": "SX9500 Touch Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "interruptGpio": "Interrupt GPIO Pin",
                  "interruptEnabled": "Touch Interrupt Enabled",
                  "gpioInstance": "GPIO Driver Instance",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "getTouchData": "Get Current Touch Data",
                  "touchDataRead": "Touch Data Read",
                  "pressUp": "Press Up",
                  "upPressed": "Up Pressed",
                  "pressDown": "Press Down",
                  "downPressed": "Down Pressed",
                  "pressLeft": "Press Left",
                  "leftPressed": "Left Pressed",
                  "pressRight": "Press Right",
                  "rightPressed": "Right Pressed"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "sx9500.h": "#ifndef __ATMO_SX9500_H_\n#define __ATMO_SX9500_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n#include \"../gpio/gpio.h\"\n\ntypedef enum {\n    ATMO_SX9500_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_SX9500_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_SX9500_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_SX9500_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_SX9500_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_SX9500_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    bool interruptEnabled;\n    ATMO_GPIO_Device_Pin_t interruptPin;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    ATMO_DriverInstanceHandle_t gpioDriverInstance;\n} ATMO_SX9500_Config_t;\n\ntypedef struct {\n\tbool downPressed;\n\tbool upPressed;\n\tbool leftPressed;\n\tbool rightPressed;\n} SX9500_TouchState_t;\n\ntypedef enum {\n\tSX9500_Touched_Any = 0,\n\tSX9500_Touched_Down,\n\tSX9500_Touched_Right,\n\tSX9500_Touched_Up,\n\tSX9500_Touched_Left,\n\tSX9500_Touched_NumEvents,\n} SX9500_TouchEvent_t;\n\n\n/**\n * Initialize SX9500 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config);\n\n/**\n * Get current touch sensor state\n *\n * @param[out] touchState\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState);\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle);\n\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb);\n\n\n#endif\n\n",
                "sx9500_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.h\n * This is the header file for the SX9500 touch controller driver.\n */\n\n#ifndef SX9500_INTERNAL_H_\n#define SX9500_INTERNAL_H_\n\n/*!\n * @addtogroup sx9500 SX9500 touch controller API\n * @{\n */\n\n#include \"../app_src/atmosphere_platform.h\"\n\n\n#define SX9500_I2C_ADDRESS                          0x28\n\n#define SX9500_REG_IRQSRC                           0x00\n#define SX9500_REG_STAT                             0x01\n#define SX9500_REG_IRQMSK                           0x03\n#define SX9500_REG_PROXCTRL0                        0x06\n#define SX9500_REG_PROXCTRL1                        0x07\n#define SX9500_REG_PROXCTRL2                        0x08\n#define SX9500_REG_PROXCTRL3                        0x09\n#define SX9500_REG_PROXCTRL4                        0x0A\n#define SX9500_REG_PROXCTRL5                        0x0B\n#define SX9500_REG_PROXCTRL6                        0x0C\n#define SX9500_REG_PROXCTRL7                        0x0D\n#define SX9500_REG_PROXCTRL8                        0x0E\n#define SX9500_REG_SENSORSEL                        0x20\n#define SX9500_REG_USEMSB                           0x21\n#define SX9500_REG_USELSB                           0x22\n#define SX9500_REG_AVGMSB                           0x23\n#define SX9500_REG_AVGLSB                           0x24\n#define SX9500_REG_DIFFMSB                          0x25\n#define SX9500_REG_DIFFLSB                          0x26\n#define SX9500_REG_OFFSETMSB                        0x27\n#define SX9500_REG_OFFSETLSB                        0x28\n#define SX9500_REG_RESET                            0x7F\n \n#define SX9500_RESET_CMD                            0xDE\n \n/*! @brief Status return codes. */\ntypedef enum\n{\n    SX9500_SUCCESS,\n    SX9500_I2C_ERROR,\n    SX9500_INTERNAL_ERROR,\n\tSX9500_NOINIT_ERROR\n} SX9500_status;\n\ntypedef union {\n    struct {    // sx9500 register 0x00\n        uint8_t txen_stat   : 1;    // 0\n        uint8_t reserved    : 2;    // 1,2\n        uint8_t conv_done   : 1;    // 3\n        uint8_t comp_done   : 1;    // 4\n        uint8_t far         : 1;    // 5\n        uint8_t close       : 1;    // 6\n        uint8_t reset       : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegIrqSrc_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x01\n        uint8_t compstat         : 4;    // 0,1,2,3\n        uint8_t proxstat0        : 1;    // 4\n        uint8_t proxstat1        : 1;    // 5\n        uint8_t proxstat2        : 1;    // 6\n        uint8_t proxstat3        : 1;    // 7\n   } bits;\n    uint8_t octet;\n} RegStat_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x06\n        uint8_t sensor_en   : 4;    // 0,1,2,3\n        uint8_t scan_period : 3;    // 4,5,6\n        uint8_t reserved    : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl0_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x09\n        uint8_t raw_filt    : 2;    // 0,1\n        uint8_t reserved    : 2;    // 2,3\n        uint8_t doze_period : 2;    // 4,5\n        uint8_t doze_en     : 1;    // 6\n        uint8_t res7        : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl3_t;\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _sx9500_fct_t\n{\n\t/** Read hardware function */\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\n    /** Write hardware register, 8bit aligned function */\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\n    /** Wait function **/\n    void (*WaitMs)(uint32_t tms);\n} sx9500_fct_t, *ptsx9500_fct_t;\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize SX9500 driver.\n *\n * @param FCT Pointer to a structure with external functions\n */\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT);\n\n/*!\n * @brief De-initialize SX9500 driver.\n *\n */\nvoid SX9500_Deinit_Driver();\n\n/*!\n * @brief Initialize SX9500 hardware.\n *\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_Init_Hw();\n\n/*!\n * @brief Get information for selected sensor.\n *\n * @param  CSn Selected sensor (0-3)\n * @param  buf Pointer to an array with PROXUSEFUL/PROXAVG/PROXDIFF values\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf);\n\n/*!\n * @brief Get power mode.\n *\n * @return Power mode: active (true/1) or low power (false/0)\n */\nbool SX9500_get_active();\n\n/*!\n * @brief Set power mode.\n *\n * @param  bool Power mode: active (true/1) or low power (false/0)\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_set_active(bool);\n\n/*!\n * @brief Function returning the triggered capacitive sensing interface.\n * @note Returns 0xFF if no interface has been triggered.\n *\n * @param  CSi Pointer to sensing interface index\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi);\n\n/*!\n * @brief Read IRQ Source\n * @note  Used to clear interrupts on SX9500\n *\n * @param irqReg Pointer to store value from IRQ register\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg);\n\n/*!\n * @brief Read Proximity Sensors\n *\n * @param data Pointer to store data from proximity sensor data\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data);\n\n/*! @}*/\n\n#endif\n"
              },
              "objects": {
                "sx9500.c": "#include \"sx9500.h\"\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_SX9500_Config_t config;\n    unsigned int abilityHandle[SX9500_Touched_NumEvents];\n\tbool abilityHandleRegistered[SX9500_Touched_NumEvents];\n    ATMO_Callback_t callback[SX9500_Touched_NumEvents];\n    bool configured;\n} ATMO_SX9500_Priv_Config;\n\nstatic ATMO_SX9500_Priv_Config _ATMO_SX9500_config = {0};\n\nstatic ATMO_I2C_Peripheral_t _ATMO_SX9500_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic uint8_t _ATMO_SX9500_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t _ATMO_SX9500_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic bool ATMO_SX9500_TouchStateToIndex(SX9500_TouchState_t *touchState, uint32_t *index)\n{\n\tbool anyPressed = false;\n\n\tif(touchState->downPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Down;\n\t}\n\tif(touchState->upPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Up;\n\t}\n\tif(touchState->rightPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Right;\n\t}\n\tif(touchState->leftPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Left;\n\t}\n\n\treturn anyPressed;\n}\n\nstatic void ATMO_SX9500_Callback(void *data)\n{\n    RegIrqSrc_t irq;\n    if (SX9500_Read_Irq(&irq.octet) == SX9500_SUCCESS)\n    {\n        if (irq.bits.close || irq.bits.far)\n        {\n        \tSX9500_TouchState_t touchState;\n        \tif(ATMO_SX9500_GetTouchState(&touchState) == ATMO_SX9500_Status_Success)\n        \t{\n        \t\tuint32_t index = 0;\n        \t\tif(ATMO_SX9500_TouchStateToIndex(&touchState, &index))\n        \t\t{\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[SX9500_Touched_Any] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[SX9500_Touched_Any], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[index] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[index], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.callback[SX9500_Touched_Any] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[SX9500_Touched_Any](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t\tif(_ATMO_SX9500_config.callback[index] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[index](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t}\n        \t}\n        \telse\n        \t{\n        \t\treturn ATMO_SX9500_Status_Fail;\n        \t}\n        }\n    }\n    else\n    {\n    \treturn ATMO_SX9500_Status_Fail;\n    }\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_SX9500_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_SX9500_config.configured = false;\n    }\n\n\tsx9500_fct_t fct;\n\tfct.I2C_Read = _ATMO_SX9500_I2CRead_Simple;\n\tfct.I2C_Write = _ATMO_SX9500_I2CWrite_Simple;\n\tfct.WaitMs = ATMO_PLATFORM_DelayMilliseconds;\n\tSX9500_Init_Driver(&fct);\n\tSX9500_Init_Hw();\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_SX9500_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    // Register interrupt\n    if(config->interruptEnabled)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->interruptPin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_SX9500_Callback);\n    }\n\n    memcpy( &_ATMO_SX9500_config.config, config, sizeof(ATMO_SX9500_Config_t) );\n    _ATMO_SX9500_config.configured = true;\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL || !_ATMO_SX9500_config.configured )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_SX9500_config.config, sizeof(ATMO_SX9500_Config_t));\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState)\n{\n\tmemset(touchState, 0, sizeof(SX9500_TouchState_t));\n\n\tRegStat_t dir;\n\tif( SX9500_Read_Proximity_Sensors(&dir.octet) != SX9500_SUCCESS )\n\t{\n\t\treturn ATMO_SX9500_Status_Fail;\n\t}\n\n\tif(dir.octet > 0)\n\t{\n\t\tif(dir.bits.proxstat0)\n\t\t{\n\t\t\ttouchState->downPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat1)\n\t\t{\n\t\t\ttouchState->rightPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat2)\n\t\t{\n\t\t\ttouchState->upPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat3)\n\t\t{\n\t\t\ttouchState->leftPressed = true;\n\t\t}\n\t}\n\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle)\n{\n\t_ATMO_SX9500_config.abilityHandle[event] = abilityHandle;\n\t_ATMO_SX9500_config.abilityHandleRegistered[event] = true;\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb)\n{\n\t_ATMO_SX9500_config.callback[event] = cb;\n\treturn ATMO_SX9500_Status_Success;\n}\n\n\n",
                "sx9500_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.c\n * This is the source file for the SX9500 touch controller driver.\n */\n\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic sx9500_fct_t FCT_SX9500;\nstatic bool m_txen;\n\n/* Define registers that need to be initialized to values different than\n * default\n */\ntypedef struct smtc_reg_data {\n    unsigned char reg;\n    unsigned char val;\n}smtc_reg_data_t;\nstatic smtc_reg_data_t sx9500_i2c_reg_setup[] = {\n    {\n        .reg = SX9500_REG_IRQMSK,\n        .val = 0x60,  /* CLOSEIRQEN[6]=1 (close interrupt is on),            */\n                      /* FARIRQEN[5]=1 (far interrupt is on),                */\n                      /* COMPDONEIRQEN[4]=0 (compensation interrupt is off), */\n                      /* CONVDONEIRQEN[3]=0 (conversion interrupt is off)    */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL1,\n        .val = 0x03,  /* SHIELDEN[7:6]=0 (no shield),              */\n                      /* RANGE[1:0]=3 (small, +/-2.5pF Full Scale) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL2,\n        .val = 0x27,  /* GAIN[6:5]=1 (digital gain x2),          */\n                      /* FREQ[4:3]=0 (83kHz sampling frequency), */\n                      /* RESOLUTION[2:0]=0 (finest resolution)   */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL3,\n        .val = 0x41,  /* DOZEEN[6]=1 (enables doze mode),   */\n                      /* DOZEPERIOD[5:4]=0 (2*scan period), */\n                      /* RAWFILT[1:0]=1 (Low)               */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL4,\n        .val = 0x80,  /* AVGTHRESH[7:0]=0x80 (threshold triggering compensation = +/-128*value (typ between 16384 and 24576) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL5,\n        .val = 0x0F,  /* AVGDEB[7:6]=0 (debounce=off),               */\n                      /* AVGNEGFILT[5:3]=1 (lowest negative filter), */\n                      /* AVGPOSFILT[2:0]=7 (highest positive filter) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL6,\n        .val = 0x06,  /* PROXTHRESH[4:0]=6 (sensitivity=120) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL7,\n        .val = 0x00,  /* AVGCOMPDIS[7]=0 (compensation enabled),      */\n                      /* COMPMETHOD[6]=0 (separate CSx compensation), */\n                      /* HYST[5:4]=0 (hysteresis=32),                 */\n                      /* CLOSEDEB[3:2]=0 (close debouncer=off),       */\n                      /* FARDEB[1:0]=0 (far debouncer=off)            */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL8,\n        .val = 0x08,  /* STUCK[7:4]=0 (stuck timeout=off),                          */\n                      /* COMPPRD[3:0]=8 (periodic compensation every 8*128 samples) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL0,\n        .val = 0x0F,  /* SCANPERIOD[6:4]=0 (scan every 30ms),  */\n                      /* SENSOREN[3:0]=15 (enable all sensors) */\n    },\n};\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\nstatic SX9500_status SX9500_write(uint8_t addr, uint8_t data)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    cmd[1] = data;\n\n    return (SX9500_status)FCT_SX9500.I2C_Write(cmd, 2);\n}\n\nstatic SX9500_status SX9500_read(uint8_t addr, uint8_t *dst_buf, uint32_t length)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    return (SX9500_status)FCT_SX9500.I2C_Read(cmd, 1, dst_buf, length);\n}\n\nstatic SX9500_status SX9500_read_single(uint8_t addr, uint8_t* val)\n{\n    return (SX9500_status)FCT_SX9500.I2C_Read(&addr, 1, val, 1);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT)\n{\n    assert((FCT != NULL) &&\n            (FCT->I2C_Read != NULL) &&\n            (FCT->I2C_Write != NULL) &&\n            (FCT->WaitMs != NULL));\n    FCT_SX9500 = *FCT;\n    initDriverDone = true;\n}\n\nvoid SX9500_Denit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        SX9500_set_active(false); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nSX9500_status SX9500_Init_Hw()\n{\n    int i = 0;\n    uint8_t val;\n    SX9500_status status;\n\n    if (!initDriverDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    // perform a soft reset\n    status = SX9500_write(SX9500_REG_RESET, SX9500_RESET_CMD);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    FCT_SX9500.WaitMs(300); // wait until the reset has finished\n\n    // read IRQSRC to release NIRQ pin\n    status = SX9500_read(SX9500_REG_IRQSRC, &val,1);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    // init I2C registers\n    int lenRegTable = sizeof(sx9500_i2c_reg_setup) / sizeof(smtc_reg_data_t);\n    while (i < lenRegTable)\n    {\n        /* Write all registers/values contained in i2c_reg */\n        status = SX9500_write(sx9500_i2c_reg_setup[i].reg, sx9500_i2c_reg_setup[i].val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        /* Read back value from register and verify write */\n        status = SX9500_read_single(sx9500_i2c_reg_setup[i].reg, &val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        if (val != sx9500_i2c_reg_setup[i].val)\n        {\n            return SX9500_INTERNAL_ERROR;\n        }\n\n        i++;\n    }\n\n    initHwDone = true;\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf)\n{\n    SX9500_status status;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(buf != NULL);\n\n    status = SX9500_write(SX9500_REG_SENSORSEL, CSn);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_USEMSB, buf, 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_AVGMSB, &buf[2], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_DIFFMSB, &buf[4], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    return SX9500_SUCCESS;\n}\n\n// get power mode (active or low power)\nbool SX9500_get_active()\n{\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    return m_txen;\n}\n\n// set active mode or low power mode\nSX9500_status SX9500_set_active(bool en)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    m_txen = en;\n\n    uint8_t val = en ? sx9500_i2c_reg_setup[10].val : 0x00U;\n\n    status = SX9500_write(SX9500_REG_PROXCTRL0, val);\n\n    return status;\n}\n\n// returns the triggered capacitive sensing interface (CS0..CS3)\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi)\n{\n    SX9500_status status = SX9500_SUCCESS;\n    RegIrqSrc_t regirq;\n    RegStat_t prox;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(CSi != NULL);\n\n    *CSi = 0xFF;\n\n    status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    if (regirq.bits.close)\n    {\n        if (prox.bits.proxstat0)\n        {\n            *CSi = 0;\n        }\n        else if (prox.bits.proxstat1)\n        {\n            *CSi = 1;\n        }\n        else if (prox.bits.proxstat2)\n        {\n            *CSi = 2;\n        }\n        else if (prox.bits.proxstat3)\n        {\n            *CSi = 3;\n        }\n    }\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != irqReg)\n    {\n        RegIrqSrc_t regirq;\n        status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n        else\n        {\n            *irqReg = regirq.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != data)\n    {\n        RegStat_t prox;\n        status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            *data = 0xFF;\n            return status;\n        }\n        else\n        {\n            *data = prox.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\n"
              }
            }
          }
        },
        "tsl2572": {
          "libName": "tsl2572",
          "manufacturer": "AMS",
          "description": "Ambient Light Sensor",
          "type": "Ambient Light Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "TSL2572AmbientLight",
              "type": "EmbeddedTSL2572",
              "icon": "EmbeddedAmbientLight.svg",
              "defaultAbility": "readAmbientLight",
              "defaultTrigger": "ambientLightRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAmbientLight",
                  "triggers": [
                    "ambientLightRead"
                  ],
                  "code": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x39"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedTSL2572": "TSL2572 Ambient Light Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readAmbientLight": "Read Ambient Light(lux)",
                  "ambientLightRead": "Ambient Light Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "tsl2572.h": "#ifndef __ATMO_TSL2572_H_\r\n#define __ATMO_TSL2572_H_\r\n\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\ntypedef enum {\r\n    ATMO_TSL2572_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_TSL2572_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_TSL2572_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_TSL2572_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_TSL2572_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_TSL2572_Status_t;\r\n\r\ntypedef struct {\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_TSL2572_Config_t;\r\n\r\n\r\n/**\r\n * Initialize TSL2572 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable TSL2572 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of TSL2572 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get ambient light intensity in lux\r\n *\r\n * @param[out] lightLux\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux);\r\n\r\n\r\n#endif\r\n",
                "tsl2572_internal.h": "/*\r\n * tsl2572.h\r\n *\r\n *  Created on: 25 sept. 2017\r\n *      Author: frq05060\r\n */\r\n\r\n#ifndef TSL2572_H_\r\n#define TSL2572_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n//enum tsl2572_status {\r\n//    sensor_success = 0,\r\n//    sensor_I2C_error = 1,\r\n//    sensor_invalid_ID = 2,\r\n//    sensor_wrong_parameter = 3\r\n//};\r\n\r\ntypedef struct _tsl2572_IoFunc_t\r\n{\r\n  uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\r\n  uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\r\n  void         (*WaitMsec)(uint32_t millisec);\r\n} tsl2572_IoFunc_t, *ptsl2572_IoFunc_t;\r\n\r\n/**\r\n * struct tsl2x7x_default_settings - power on defaults unless\r\n *                                   overridden by platform data.\r\n *  @als_time:              ALS Integration time - multiple of 50mS\r\n *  @als_gain:              Index into the ALS gain table.\r\n *  @als_gain_level:        ALS gain level (When asserted, the 1 and 8 ALS gain (AGAIN) modes are scaled by 0.16)\r\n *  @wait_time:             Time between PRX and ALS cycles\r\n *                          in 2.7 periods\r\n *  @wlong:                 When asserted, the wait cycles are increased by a factor 12 from that programmed in the WTIME register\r\n *  @interrupts_enable:     Enable/Disable als interrupts\r\n *  @persistence:           H/W Filters, Number of 'out of limits'\r\n *                          ADC readings ALS.\r\n *  @als_thresh_low:        CH0 'low' count to trigger interrupt.\r\n *  @als_thresh_high:       CH0 'high' count to trigger interrupt.\r\n *  @als_enable:            This bit actives the two channel ADC\r\n *  @wait_enable:           This bit activates the wait feature.\r\n *  @power_on:              This bit activates the internal oscillator to permit the timers and ADC channels to operate\r\n *  @glass_attenuation:     scaling factor referred to as glass attenuation (GA) can be used to compensate for attenuation\r\n */\r\nstruct tsl2x7x_settings {\r\n    uint8_t als_time;\r\n    uint8_t als_gain;\r\n    bool als_gain_level;\r\n    uint8_t wait_time;\r\n    bool wlong;\r\n    bool  interrupts_enable;\r\n    uint8_t  persistence;\r\n    uint16_t als_thresh_low;\r\n    uint16_t als_thresh_high;\r\n    bool als_enable;\r\n    bool wait_enable;\r\n    bool power_on;\r\n    float glass_attenuation;\r\n};\r\n\r\n/****************************************************************************\r\n * Function Prototypes\r\n ****************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc);\r\nuint8_t TSL2572_Init_HW(void);\r\nuint8_t TSL2572_ReadAmbientLight(float *lux);\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN);\r\nuint8_t TSL2572_ClearALSInterrupt(void);\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS);\r\nuint8_t TSL2572_Enable_ALS(bool AEN);\r\nuint8_t TSL2572_Power_ON(bool PON);\r\nuint8_t TSL2572_Enable_Wait(bool WEN);\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData);\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData);\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG);\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL);\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME);\r\n\r\n#endif /* TSL2572_H_ */\r\n"
              },
              "objects": {
                "tsl2572.c": "#include \"tsl2572.h\"\r\n#include \"tsl2572_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_TSL2572_Config_t config;\r\n    bool configured;\r\n} ATMO_TSL2572_Priv_Config;\r\n\r\nstatic ATMO_TSL2572_Priv_Config _ATMO_TSL2572_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t _ATMO_TSL2572_i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool tsl2572Enabled = true;\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config)\r\n{\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_TSL2572_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n    \t_ATMO_TSL2572_config.configured = false;\r\n    }\r\n\r\n    tsl2572_IoFunc_t io;\r\n    io.I2C_Read = _ATMO_TSL2572_I2CRead_Simple;\r\n    io.I2C_Write = _ATMO_TSL2572_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    TSL2572_Init_Driver(&io);\r\n    TSL2572_Init_HW();\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled)\r\n{\r\n    tsl2572Enabled = enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = tsl2572Enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_TSL2572_i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy( &_ATMO_TSL2572_config.config, config, sizeof(ATMO_TSL2572_Config_t) );\r\n    _ATMO_TSL2572_config.configured = true;\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_TSL2572_config.configured )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_TSL2572_config.config, sizeof(ATMO_TSL2572_Config_t));\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux)\r\n{\r\n    if(!tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n    \r\n\tif( TSL2572_ReadAmbientLight(lightLux) != 0 )\r\n\t{\r\n\t\treturn ATMO_TSL2572_Status_Fail;\r\n\t}\r\n\r\n\treturn ATMO_TSL2572_Status_Success;\r\n}\r\n\r\n\r\n\r\n",
                "tsl2572_internal.c": "/*\r\n * tsl2572.c\r\n *\r\n *  Created on: 25 sept. 2017\r\n *      Author: frq05060\r\n */\r\n\r\n#include \"tsl2572_internal.h\"\r\n\r\n/* TSL2572 Register definitions */\r\n#define TSL2572_I2C_SLAVE_ADDRESS        0x39\r\n#define TSL2572_DEVICE_ID                0x34    // TSL25721\r\n#define TSL2572_REG_ENABLE               0x00\r\n#define TSL2572_REG_ATIME                0x01\r\n#define TSL2572_REG_WTIME                0x03\r\n#define TSL2572_REG_AILTL                0x04\r\n#define TSL2572_REG_AILTH                0x05\r\n#define TSL2572_REG_AIHTL                0x06\r\n#define TSL2572_REG_AIHTH                0x07\r\n#define TSL2572_REG_PERS                 0x0C\r\n#define TSL2572_REG_CONFIG               0x0D\r\n#define TSL2572_REG_CONTROL              0x0F\r\n#define TSL2572_REG_ID                   0x12\r\n#define TSL2572_REG_STATUS               0x13\r\n#define TSL2572_REG_C0DATA               0x14\r\n#define TSL2572_REG_C0DATAH              0x15\r\n#define TSL2572_REG_C1DATA               0x16\r\n#define TSL2572_REG_C1DATAH              0x17\r\n\r\n/* tsl2572 COMMAND register masks */\r\n#define TSL2572_COMMAND_MSK              0x80\r\n#define TSL2572_TYPE_REPEAT_MSK          0x00\r\n#define TSL2572_TYPE_AUTO_INC_MSK        0x20\r\n#define TSL2572_TYPE_SPL_FN_MSK          0x60\r\n#define TSL2572_ADD_ALS_INT_CLR_MSK      0x06\r\n\r\n/* tsl2572 CONTROL register masks */\r\n#define TSL2572_AGAIN_MASK               0x03\r\n\r\n/* tsl2572 CONFIG register masks */\r\n#define TSL2572_AGL_MSK                  0x04\r\n#define TSL2572_WLONG_MSK                0x02\r\n\r\n/* tsl2572 PERS register masks */\r\n#define TSL2572_APERS_MSK                0x0F\r\n\r\n/* tsl2572 ENABLE register masks */\r\n#define TSL2572_AIEN_MSK                 0x10\r\n#define TSL2572_AEN_MSK                  0x02\r\n#define TSL2572_WEN_MSK                  0x08\r\n#define TSL2572_PON_MSK                  0x01\r\n\r\nenum tsl2572_status {\r\n    TSL2572_sensor_success = 0,\r\n    TSL2572_sensor_I2C_error = 1,\r\n    TSL2572_sensor_invalid_ID = 2,\r\n    TSL2572_sensor_wrong_parameter = 3\r\n};\r\n\r\nstatic const struct tsl2x7x_settings tsl2x7x_default_settings = {\r\n        0xDB,\r\n        0,\r\n        true,\r\n        74,\r\n        false,\r\n        true,\r\n        1,\r\n        100,\r\n        300,\r\n        true,\r\n        true,\r\n        true,\r\n        1\r\n};\r\n\r\n/***********************************************************************************/\r\n/* variables                                                                       */\r\n/***********************************************************************************/\r\nstatic tsl2572_IoFunc_t sTSL2572_Func;\r\nuint8_t gain_val = 0;\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_Driver                                                          */\r\n/* wrap the low level function (I2C write, I2C read, WaitMsec)                  */\r\n/* required by TSL2572 driver                                                   */\r\n/* Note : this function does not initialize the HW                              */\r\n/********************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc){\r\n    sTSL2572_Func = *pIoFunc;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_HW                                                              */\r\n/* initialize the HW                                                            */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Init_HW(void){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* check device ID */\r\n    wBuf[0] = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    if (rBuf != TSL2572_DEVICE_ID){\r\n        return TSL2572_sensor_invalid_ID;\r\n    }\r\n\r\n    /* Set ALS gain */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSGain(tsl2x7x_default_settings.als_gain,tsl2x7x_default_settings.als_gain_level)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Set ALS time */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSTime(tsl2x7x_default_settings.als_time)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* configure the wait time */\r\n    if (TSL2572_sensor_success != TSL2572_SetWaitTime(tsl2x7x_default_settings.wait_time,tsl2x7x_default_settings.wlong)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt thresholds */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSThresholds(tsl2x7x_default_settings.als_thresh_low,tsl2x7x_default_settings.als_thresh_high)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt persistence */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSPersistence(tsl2x7x_default_settings.persistence)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* ALS Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_ALS(tsl2x7x_default_settings.als_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Wait Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_Wait(tsl2x7x_default_settings.wait_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Power ON  */\r\n    if (TSL2572_sensor_success != TSL2572_Power_ON(tsl2x7x_default_settings.power_on)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* clear the sensor IRQ status */\r\n    if (TSL2572_sensor_success != TSL2572_ClearALSInterrupt()){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if (TSL2572_sensor_success != TSL2572_EnableALSInterrupts(tsl2x7x_default_settings.interrupts_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAmbientLight                                                     */\r\n/* sample CH0 and CH1 photo_diodes and compute the human eye response to        */\r\n/* light intensity (in lux)                                                     */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAmbientLight(float *lux){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n    int c0,c1;\r\n    float lux1,lux2,cpl;\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    c0 = rBuf[1]<<8 | rBuf[0];\r\n    c1 = rBuf[3]<<8 | rBuf[2];\r\n\r\n    //see TSL2572 datasheet\r\n    cpl = (2.73 * (256-tsl2x7x_default_settings.als_time)) * gain_val / (tsl2x7x_default_settings.glass_attenuation * 60);\r\n    if (tsl2x7x_default_settings.als_gain_level){\r\n        cpl /= 6;\r\n    }\r\n    lux1 = ((float)c0 - (1.87 * (float)c1)) / cpl;\r\n    lux2 = ((0.63 * (float)c0) - (float)c1) / cpl;\r\n    cpl = lux1 >= lux2 ? lux1 : lux2; //max(lux1, lux2);\r\n    *lux = ((cpl >= 0.0) ? cpl : 0.0); //max(cpl, 0.0);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSGain                                                           */\r\n/* AGAIN = 0     ALS Gain value = 1 * gain                                      */\r\n/* AGAIN = 1     ALS Gain value = 8 * gain                                      */\r\n/* AGAIN = 2     ALS Gain value = 16 * gain                                     */\r\n/* AGAIN = 3     ALS Gain value = 120 * gain                                    */\r\n/* AGL = 0       AGAIN = 0 or 1 or 2 or 3     -> scaling by 1                   */\r\n/* AGL = 1       AGAIN = 0 or 1               -> scaling by 0.16                */\r\n/* Do not use AGL = 1 with AGAIN = 2 or 3                                       */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    if ((AGAIN > 1) && (AGL)){\r\n        return TSL2572_sensor_wrong_parameter;\r\n    }\r\n\r\n    wBuf[0] = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = AGAIN & TSL2572_AGAIN_MASK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AGL bit */\r\n    if (AGL){\r\n        wBuf[1] = rBuf | TSL2572_AGL_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AGL_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if ((AGAIN & TSL2572_AGAIN_MASK) == 0) gain_val = 1;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 1) gain_val = 8;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 2) gain_val = 16;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 3) gain_val = 120;\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSTime                                                           */\r\n/* set ALS Time = the ALS ADC integration time                                  */\r\n/* ATIME = 0xFF     ALS integration cycles = 1,   time = 2.73ms                 */\r\n/* ATIME = 0xF6     ALS integration cycles = 10,  time = 27.3ms                 */\r\n/* ATIME = 0xDB     ALS integration cycles = 37,  time = 101ms                  */\r\n/* ATIME = 0xC0     ALS integration cycles = 64,  time = 175ms                  */\r\n/* ATIME = 0x00     ALS integration cycles = 256, time = 699ms                  */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = ATIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* set ALS interrupt threshold low and threshold high                             */\r\n/* the thresholds refer to C0 photo_diode only                                     */\r\n/* (C1 is not used to trigger interrupts)                                        */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[5];\r\n\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = (uint8_t)(ALS_interrupt_Low_Threshold & 0x00FF);\r\n    wBuf[2] = (uint8_t)((ALS_interrupt_Low_Threshold & 0xFF00) >> 8);\r\n    wBuf[3] = (uint8_t)(ALS_interrupt_High_Threshold & 0x00FF);\r\n    wBuf[4] = (uint8_t)((ALS_interrupt_High_Threshold & 0xFF00) >> 8);\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* get ALS interrupt threshold low and threshold high                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    *ALS_interrupt_Low_Threshold = (uint16_t) (rBuf[1]<<8 | rBuf[0]);\r\n    *ALS_interrupt_High_Threshold = (uint16_t) (rBuf[3]<<8 | rBuf[2]);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSPersistence                                                    */\r\n/* set ALS interrupt persistence filter                                            */\r\n/* APERS = 0     every ALS cycle generates an interrupt                           */\r\n/* APERS = 1     1 value outside of threshold range generates an interrupt        */\r\n/* APERS = 2     2 consecutive values out of range generates an interrupt         */\r\n/* APERS = 3     3 consecutive values out of range generates an interrupt         */\r\n/* APERS = 4     5 consecutive values out of range generates an interrupt         */\r\n/* APERS = 5     10 consecutive values out of range generates an interrupt         */\r\n/* APERS = 6     15 consecutive values out of range generates an interrupt         */\r\n/* APERS = 7     20 consecutive values out of range generates an interrupt         */\r\n/* APERS = 8     25 consecutive values out of range generates an interrupt         */\r\n/* APERS = 9     30 consecutive values out of range generates an interrupt         */\r\n/* APERS = 10    35 consecutive values out of range generates an interrupt         */\r\n/* APERS = 11    40 consecutive values out of range generates an interrupt         */\r\n/* APERS = 12    45 consecutive values out of range generates an interrupt         */\r\n/* APERS = 13    50 consecutive values out of range generates an interrupt         */\r\n/* APERS = 14    55 consecutive values out of range generates an interrupt         */\r\n/* APERS = 15    60 consecutive values out of range generates an interrupt         */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = APERS & TSL2572_APERS_MSK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetWaitTime                                                             */\r\n/* WTIME = 0xFF     Wait time = 2.73ms (WLONG = 0), 0.033s (WLONG = 1)           */\r\n/* WTIME = 0xB6     Wait time = 202ms (WLONG = 0), 2.4s (WLONG = 1)               */\r\n/* WTIME = 0x00     Wait time = 699ms (WLONG = 0), 8.4s (WLONG = 1)               */\r\n/* The Wait time register should be configured before TSL2572_Enable_ALS(true)    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    wBuf[0] = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = WTIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WLONG bit */\r\n    if (WLONG){\r\n        wBuf[1] = rBuf | TSL2572_WLONG_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WLONG_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AIEN bit */\r\n    if (AIEN){\r\n        wBuf[1] = rBuf | TSL2572_AIEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AIEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_ClearALSInterrupt(void){\r\n    uint8_t wBuf;\r\n\r\n    wBuf = TSL2572_COMMAND_MSK | TSL2572_TYPE_SPL_FN_MSK | TSL2572_ADD_ALS_INT_CLR_MSK;\r\n    if (sTSL2572_Func.I2C_Write(&wBuf, sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_ALS                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_ALS(bool AEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AEN bit */\r\n    if (AEN){\r\n        wBuf[1] = rBuf | TSL2572_AEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_Wait                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_Wait(bool WEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WEN bit */\r\n    if (WEN){\r\n        wBuf[1] = rBuf | TSL2572_WEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Power_ON                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Power_ON(bool PON){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask PON bit */\r\n    if (PON){\r\n        wBuf[1] = rBuf | TSL2572_PON_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_PON_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAllRegisters                                                        */\r\n/* RegData contains 16 * uint8_t                                                */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read ENABLE register */\r\n    wBuf = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ATIME register */\r\n    wBuf = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read WTIME register */\r\n    wBuf = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTL register */\r\n    wBuf = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTH register */\r\n    wBuf = TSL2572_REG_AILTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTL register */\r\n    wBuf = TSL2572_REG_AIHTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTH register */\r\n    wBuf = TSL2572_REG_AIHTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read PERS register */\r\n    wBuf = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONFIG register */\r\n    wBuf = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONTROL register */\r\n    wBuf = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ID register */\r\n    wBuf = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read STATUS register */\r\n    wBuf = TSL2572_REG_STATUS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATA register */\r\n    wBuf = TSL2572_REG_C1DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATAH register */\r\n    wBuf = TSL2572_REG_C1DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadCH0                                                                 */\r\n/* RegData contains 2 * uint8_t                                                    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n"
              }
            }
          }
        },
        "mpl3115": {
          "libName": "mpl3115",
          "description": "NXP MPL3115 Pressure and Altitude Sensor",
          "type": "Pressure + Altitute Sensor",
          "icon": "",
          "manufacturer": "NXP Semiconductors",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "MPL3115Pressure",
              "type": "EmbeddedMPL3115",
              "icon": "EmbeddedPressure.svg",
              "defaultAbility": "readPressure",
              "defaultTrigger": "pressureRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_MPL3115_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.MPLsettings.mode = MPL_MODE_PRESSURE;\n\tconfig.MPLsettings.oversample = MPL_OS_0;\t\t\t// oversampling = 1\n\tconfig.MPLsettings.autoAcquisitionTime = MPL_ST_0;\t// Auto acquisition time = 1s\n\tconfig.MPLsettings.pressureOffset = ATMO_PROPERTY(undefined, pressureOffset);\t// Offset pressure correction = 4*-128 = -512Pa (8 bits signed integer)\n\tconfig.MPLsettings.altitudeOffset = ATMO_PROPERTY(undefined, altitudeOffset);\t// Offset altitude correction = 128m (signed 8 bits integer)\n\tconfig.MPLsettings.tempOffset = ATMO_PROPERTY(undefined, tempOffset);\t\t\t// Offset temperature correction -8C (0.0625C/LSB)\n\tconfig.MPLsettings.fifoMode = FIFO_DISABLED;\t\t// FIFO mode disabled\n\tconfig.MPLsettings.fifoWatermark = 5;\t\t\t\t// 6 bits to set the number of FIFO samples required to trigger a watermark interrupt.\n\tconfig.MPLsettings.fifoINTpin = FIFO_INT1;\t\t\t// set pin INT1 as output for FIFO interrupt\n\n\treturn ( ATMO_MPL3115_Init(&config) == ATMO_MPL3115_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_MPL3115_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAltitude",
                  "triggers": [
                    "altitudeRead"
                  ],
                  "code": "    uint32_t altitudeMeters;\n    if(ATMO_MPL3115_GetAltitude(&altitudeMeters) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)altitudeMeters);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressure",
                  "triggers": [
                    "pressureRead"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)pressurePa);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressureKpa",
                  "triggers": [
                    "pressureReadKpa"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)(pressurePa/1000));\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x60"
                },
                {
                  "name": "pressureOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "altitudeOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "tempOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedMPL3115": "MPL3115 Pressure",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readAltitude": "Read Altitude",
                  "readPressure": "Read Pressure",
                  "readPressureKpa": "Read Pressure (kPa)",
                  "pressureRead": "Pressure Read",
                  "altitudeRead": "Altitude Read",
                  "pressureReadKpa": "Pressure Read (kPa)",
                  "pressureOffset": "Pressure Offset",
                  "altitudeOffset": "Altitude Offset",
                  "tempOffset": "Temperature Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "mpl3115.h": "#ifndef __ATMO_MPL3115_H_\n#define __ATMO_MPL3115_H_\n\n#include \"mpl3115_internal.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_MPL3115_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_MPL3115_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_MPL3115_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_MPL3115_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_MPL3115_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_MPL3115_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n\tsettingsMPL_t MPLsettings;\n} ATMO_MPL3115_Config_t;\n\n\n/**\n * Initialize MPL3115 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config);\n\n/**\n * Enable/Disable MPL3115 Driver\n *\n * @param[in] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of MPL3115 driver\n *\n * @param[out] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config);\n\n/**\n * Get Barometeric Pressure in Pascals\n * \n * @param[out] pressurePascals\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperature\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Altitude in meters\n * \n * @param[out] altitudeMeters\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters);\n\n#endif\n",
                "mpl3115_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the header file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#ifndef MPL3115_H_\n#define MPL3115_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*!\n * @addtogroup mpl3115 MPL3115 atmospheric pressure sensor\n * This module provides the API to operate the MPL3115 atmospheric pressure sensor through an I2C interface.\n *\n * The MPL3115A2 is a compact, piezoresistive, absolute pressure sensor with an I2C\n * digital interface. MPL3115A2 has a wide operating range of 20 kPa to 110 kPa, a range\n * that covers all surface elevations on earth. The MEMS is temperature compensated\n * utilizing an on-chip temperature sensor. The pressure and temperature data is fed into\n * a high resolution ADC to provide fully compensated and digitized outputs for pressure\n * in Pascals and temperature in C.\n *\n * Usage\n *-----------------------------------------------------------------------------------------------------------\n *\n * Initialization:\n * @code\n *\n *  #include \"mpl3115.h\"\n *\n *  mpl3115_IoFunc_t MPL3115_sensor;\n *  MPL3115_sensor.I2C_Read = App_I2C1_Read;\n *  MPL3115_sensor.I2C_Write = App_I2C1_Write;\n *  MPL3115_sensor.WaitMsec = App_WaitMsec;\n *\n *  MPL3115_Init_Driver(&MPL3115_sensor);\n *  MPL3115_Init_Hw();\n * @endcode\n *\n * Basic Operation:\n * @code\n *\n *  int32_t data;\n *\n *  if (MPL_ReadRawData (MPL_MODE_PRESSURE, &data) == 0)\n *  {\n *        data /= 400; // in HPa (LSB = 0.25Pa)\n *  }\n *\n * @endcode\n *\n * @{\n */\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _mpl3115_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);     /*!< Function pointer to I2C Read function. */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);                                         /*!< Function pointer to I2C Write function. */\n    void      (*WaitMsec)(uint32_t millisec);                                                                                   /*!< Function pointer to waitMsec function  */\n} mpl3115_IoFunc_t, *pmpl3115_IoFunc_t;\n\ntypedef int16_t mE_t;\n\n/*! @brief Status return codes. */\ntypedef enum\n{\n    MPL_SUCCESS,            /*!< Function ran successfully. */\n    MPL_ERROR,              /*!< Error in running function. */\n    MPL_PROTOCOL_ERROR,     /*!< Protocol error has occurred. */\n    MPL_INIT_ERROR,         /*!< Initialization error has occurred. */\n    MPL_TIMEOUT,            /*!< MPL function has timed out */\n    MPL_NOT_SUPPORTED       /*!< Not Supported */\n} mpl_status_t;\n\n/*! @brief Oversampling factor */\ntypedef enum {\n    MPL_OS_0,               /*!< Oversample Ratio = 1    */\n    MPL_OS_1,               /*!< Oversample Ratio = 2    */\n    MPL_OS_2,               /*!< Oversample Ratio = 4    */\n    MPL_OS_3,               /*!< Oversample Ratio = 8    */\n    MPL_OS_4,               /*!< Oversample Ratio = 16   */\n    MPL_OS_5,               /*!< Oversample Ratio = 32   */\n    MPL_OS_6,               /*!< Oversample Ratio = 64   */\n    MPL_OS_7                /*!< Oversample Ratio = 128  */\n} overSampleMPL_t;\n\n/*! @brief Auto acquisition time step : power(2; MPL_ST_X) */\ntypedef enum {\n    MPL_ST_0,               /*!< Auto acquistion time step = 1 second       */\n    MPL_ST_1,               /*!< Auto acquistion time step = 2 seconds      */\n    MPL_ST_2,               /*!< Auto acquistion time step = 4 seconds      */\n    MPL_ST_3,               /*!< Auto acquistion time step = 8 seconds      */\n    MPL_ST_4,               /*!< Auto acquistion time step = 16 seconds     */\n    MPL_ST_5,               /*!< Auto acquistion time step = 32 seconds     */\n    MPL_ST_6,               /*!< Auto acquistion time step = 64 seconds     */\n    MPL_ST_7,               /*!< Auto acquistion time step = 128 seconds    */\n    MPL_ST_8,               /*!< Auto acquistion time step = 256 seconds    */\n    MPL_ST_9,               /*!< Auto acquistion time step = 512 seconds    */\n    MPL_ST_10,              /*!< Auto acquistion time step = 1024 seconds   */\n    MPL_ST_11,              /*!< Auto acquistion time step = 2048 seconds   */\n    MPL_ST_12,              /*!< Auto acquistion time step = 4096 seconds   */\n    MPL_ST_13,              /*!< Auto acquistion time step = 8192 seconds   */\n    MPL_ST_14,              /*!< Auto acquistion time step = 16384 seconds  */\n    MPL_ST_15               /*!< Auto acquistion time step = 32768 seconds  */\n} autoAcquisitionTime_t;\n\n/*! @brief Device Mode */\ntypedef enum {\n    MPL_MODE_PRESSURE    = 0,   /*!< Device is in barometer mode. It reports an absolute pressure.  */\n    MPL_MODE_ALTITUDE    = 1,   /*!< Device is in altimeter mode. The pressure data is converted to equivalent altitude based on US standard atmosphere */\n    MPL_MODE_TEMPERATURE = 2,   /*!< This mode provides temperature from a high resolution temperature sensor. */\n    MPL_MODE_CURRENT     = 0xFF\n} modeMPL_t;\n\n/*! @brief Fifo Mode */\ntypedef enum {\n    FIFO_DISABLED,        /*!< FIFO is disabled (reset value) */\n    FIFO_CIRCULAR,        /*!< FIFO contains the most recent samples when overflowed (circular buffer). Oldest sample is discarded to be replaced by new sample*/\n    FIFO_STOP_OVERFLOW    /*!< FIFO stops accepting new samples when overflowed */\n} modeFIFO_t;\n\n/*! @brief Pin to route FIFO interrupt */\ntypedef enum {\n    FIFO_INT1    = 1,   /*!< FIFO Interrupt routed to INT1 pin */\n    FIFO_INT2    = 0    /*!< FIFO Interrupt routed to INT2 pin */\n} pinINT_t;\n\n/* structure that contains MPL settings */\ntypedef struct {\n    modeMPL_t                 mode;                    /*!< device mode, altimeter or barometer */\n    overSampleMPL_t           oversample;              /*!< oversampling ratio */\n    autoAcquisitionTime_t     autoAcquisitionTime;     /*!< Auto acquisition time step */\n    int8_t                    pressureOffset;          /*!< Offset pressure correction (signed: 4 Pa/LSB) */\n    int8_t                    altitudeOffset;          /*!< Offset altitude correction (signed: 1m/LSB) */\n    int8_t                    tempOffset;              /*!< Offset temperature correction -8C (signed: 0.0625C/LSB) */\n    modeFIFO_t                fifoMode;                /*!< FIFO mode */\n    uint8_t                   fifoWatermark;           /*!< These (6) bits set the number of FIFO samples required to trigger a watermark interrupt. */\n    pinINT_t                  fifoINTpin;              /*!< Pin to route FIFO interrupt */\n} settingsMPL_t;\n\n/* MPL3115 I2C slave address */\n#define MPL3115_I2C_SLAVE_ADDRESS                (uint8_t)0x60\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize MPL3115 driver.\n * @note  Wrap the low level functions (I2C write, I2C read, WaitMsec).\n * @param pIoFunc  Pointer to a structure with external functions\n */\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc);\n\n/*!\n * @brief De-initialize MPL3115 driver.\n *\n */\nvoid MPL3115_Deinit_Driver();\n\n/*!\n * @brief Initialize MPL3115 hardware.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings);\n\n/*!\n * @brief Soft reset.\n * @note\n * The reset mechanism can be enabled in standby and active mode.\\n\n * When this bit is enabled, the reset mechanism resets all functional block\n * registers and loads the respective internal registers with default values\n * If the system was already in standby mode, the reboot process will\\n\n * immediately begin; else if the system was in active mode, the boot mechanism\n * will automatically transition the system from active mode to standby mode,\n * and only then can the reboot process begin.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SoftReset();\n\n/*!\n * @brief Toggle the OST bit.\n * @note Clears then sets the OST bit which causes the sensor to immediately\n * take another reading, necessary to sample faster than 1Hz.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ToggleOneShot();\n\n/*!\n * @brief Read the chip ID.\n *\n * @param sensorID Chip ID value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetID(uint8_t* sensorID);\n\n/*!\n * @brief Set the device mode (barometer or altimeter).\n *\n * @param mode 1 - barometer\n *             0 - altimeter\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetMode (modeMPL_t mode);\n\n/*!\n * @brief Put the sensor in stand-by mode.\n * @note It is needed to modify major control registers.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GotoStandby ();\n\n/*!\n * @brief Put the sensor in active mode.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetActive();\n\n/*!\n * @brief Set the over-sample rate.\n * @note\n * Datasheet calls for 128, but you can set it from 1 to 128 samples.\n * The higher the oversample rate, the greater the time between data samples.\n *\n * @param sampleRate Over-sample rate value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate);\n\n/*!\n * @brief Set the auto-acquisition time step.\n * @note\n * Reset value = 0.\\n\n * Step is power(2; sampleTime).\n *\n * @param sampleTime Sample time value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetAutoAcquisitionTime (uint8_t sampleTime);\n\n/*!\n * @brief Enable pressure and temperature measurement event flags.\n * @note This is recommended in datasheet during setup.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_EnableEventFlags();\n\n/*!\n * @brief Set the offset pressure correction.\n * @note\n * Pressure user accessible offset trim value number.\\n\n * The user offset registers may be adjusted to enhance accuracy and optimize\n * the system performance.\\n\n * Range is from 512 to +508 Pa, 4 Pa/LSB.\n *\n * @param pressOffset Pressure offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset);\n\n/*!\n * @brief Set the offset altitude correction.\n * @note\n * Altitude user accessible offset trim value number.\\n\n * The user offset register provides user adjustment to the vertical height of\n * the altitude output.\\n\n * The range of values are from 128 to +127 meters.\n *\n * @param altitudeOffset Altitude offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset);\n\n/*!\n * @brief Set the offset temperature correction.\n * @note\n * Temperature user accessible offset trim value number.\\n\n * The range of values is from 8 to +7.9375 C, 0.0625 C/LSB.\n *\n * @param temperatureOffset Temperature offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset);\n\n/*!\n * @brief Set the FIFO mode\n * @note\n * It can be configured in either circular buffer or in overflow mode.\\n\n * In circular buffer mode, a watermark can be set to trigger a flag event.\n * Exceeding the watermark, count does not stop the FIFO from accepting new\n * data, the oldest data is overwritten.\n *\n * @param fMode FIFO mode\n * @param fWmrk Watermark\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk);\n\n/*!\n * @brief Setup the FIFO interrupt and route it to pin INT1 or INT2\n *\n * @param pinINT Interrupt pin selection (INT1 or INT2)\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT);\n\n/*!\n * @brief Disable the FIFO interrupt\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_DisableFifoInterrupt();\n\n/*!\n * @brief Read the FIFO status register.\n *\n * @param fifoStatus Pointer to FIFO status\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus);\n\n/*!\n * @brief Read sensor raw data\n *\n * @param  mode Sensor mode (pressure, altitude...)\n * @param  sensorData Pointer to the sensor data\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData);\n\n/*!\n * @brief Read all the chip registers\n *\n * @param  sensorReg Pointer to the register dump\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Dump(uint8_t* sensorReg);\n\n/*! @}*/\n\n#endif /* MPL3115_H_ */\n"
              },
              "objects": {
                "mpl3115.c": "#include \"mpl3115.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_MPL3115_Config_t config;\n    bool configured;\n} ATMO_MPL3115_Priv_Config;\n\nstatic ATMO_MPL3115_Priv_Config _ATMO_MPL3115_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_MPL3115_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool mpl3115Enabled = true;\n\nstatic uint8_t ATMO_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\n\nstatic uint8_t ATMO_MPL3115_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_MPL3115_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_MPL3115_config.configured = false;\n    }\n\n    mpl3115_IoFunc_t io;\n    io.I2C_Read = ATMO_I2CRead_Simple;\n    io.I2C_Write = ATMO_MPL3115_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    MPL3115_Init_Driver(&io);\n    MPL3115_Init_Hw(&config->MPLsettings);\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled)\n{\n    mpl3115Enabled = enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled)\n{\n    *enabled = mpl3115Enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_MPL3115_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy( &_ATMO_MPL3115_config.config, config, sizeof(ATMO_MPL3115_Config_t) );\n    _ATMO_MPL3115_config.configured = true;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !_ATMO_MPL3115_config.configured )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_MPL3115_config.config, sizeof(ATMO_MPL3115_Config_t));\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)pressurePascals) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *pressurePascals = (*pressurePascals) / 4;\n\n    return ATMO_MPL3115_Status_Success;\n        \n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_TEMPERATURE, (int32_t *)temperatureCelsius) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *temperatureCelsius = (*temperatureCelsius) / 16;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n    \n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)altitudeMeters) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *altitudeMeters = (*altitudeMeters) / 16;\n\n    return ATMO_MPL3115_Status_Success; \n}\n\n\n\n\n",
                "mpl3115_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the source file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#include \"mpl3115_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/* unshifted 7-bit I2C address */\n#define MPL_I2C_ADDRESS  (0x60)\n\n#define REG_STATUS      (0x00)\n#define OUT_P_MSB       (0x01)\n#define OUT_P_CSB       (0x02)\n#define OUT_P_LSB       (0x03)\n#define OUT_T_MSB       (0x04)\n#define OUT_T_LSB       (0x05)\n#define DR_STATUS       (0x06)\n#define OUT_P_DELTA_MSB (0x07)\n#define OUT_P_DELTA_CSB (0x08)\n#define OUT_P_DELTA_LSB (0x09)\n#define OUT_T_DELTA_MSB (0x0A)\n#define OUT_T_DELTA_LSB (0x0B)\n#define WHO_AM_I        (0x0C)\n#define F_STATUS        (0x0D)\n#define F_DATA          (0x0E)\n#define F_SETUP         (0x0F)\n#define TIME_DLY        (0x10)\n#define SYSMOD          (0x11)\n#define INT_SOURCE      (0x12)\n#define PT_DATA_CFG     (0x13)\n#define BAR_IN_MSB      (0x14)\n#define BAR_IN_LSB      (0x15)\n#define P_TGT_MSB       (0x16)\n#define P_TGT_LSB       (0x17)\n#define T_TGT           (0x18)\n#define P_WND_MSB       (0x19)\n#define P_WND_LSB       (0x1A)\n#define T_WND           (0x1B)\n#define P_MIN_MSB       (0x1C)\n#define P_MIN_CSB       (0x1D)\n#define P_MIN_LSB       (0x1E)\n#define T_MIN_MSB       (0x1F)\n#define T_MIN_LSB       (0x20)\n#define P_MAX_MSB       (0x21)\n#define P_MAX_CSB       (0x22)\n#define P_MAX_LSB       (0x23)\n#define T_MAX_MSB       (0x24)\n#define T_MAX_LSB       (0x25)\n#define MPL_CTRL_REG1   (0x26)\n#define MPL_CTRL_REG2   (0x27)\n#define MPL_CTRL_REG3   (0x28)\n#define MPL_CTRL_REG4   (0x29)\n#define MPL_CTRL_REG5   (0x2A)\n#define OFF_P           (0x2B)\n#define OFF_T           (0x2C)\n#define OFF_H           (0x2D)\n\n// SHIFTS\n#define MPL_OS_SHIFT    (3)\n\n#define MPL_TDR_SHIFT   (1)\n#define MPL_PDR_SHIFT   (2)\n#define MPL_PTDR_SHIFT  (3)\n\n#define MPL_SBYB_SHIFT  (0)\n#define MPL_OST_SHIFT   (1)\n#define MPL_RST_SHIFT   (2)\n\n#define INT_EN_FIFO_SHIFT   (6)\n#define INT_CFG_FIFO_SHIFT  (6)\n\n// MASKS\n#define MPL_OS_MASK         (0x7 << MPL_OS_SHIFT)\n#define MPL_F_WMRKK_MASK    0xF\n\n/* MPL3115 CTRL_REG1 register */\n#define MPL_RST             (1 << 2)\n#define MPL_OST             (1 << 1)\n#define MPL_SBYB            (1 << 0)\n\n/***********************************************************************************/\n/* variables                                                                       */\n/***********************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic mpl3115_IoFunc_t sIoFunc;\n\n/* variable which denotes the sensor working as altimeter/barometer */\nstatic modeMPL_t selectedMode = MPL_MODE_PRESSURE;\n\nstatic uint16_t\nselectedSampleRate  = 0xA5A5,\nselectedDelay       = 0xA5A5;\n\n/* oversample factor */\nstatic uint16_t overSampleFactors[] = { 1,  2,  4,  8, 16,  32,  64, 128 };\n/* min. time between data samples in [ms] */\nstatic uint16_t overSampleDelays[]  = { 6, 10, 18, 34, 66, 130, 258, 512 };\n\nstatic settingsMPL_t settings;\n\n\n/*****************************************************************************\n * Static functions\n ****************************************************************************/\n\n/*\n * @brief Initialize the internal structures.\n *\n * @param mplSettings Pointer to the internal settings structure\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Init(const settingsMPL_t* mplSettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    memcpy( (void*)&settings, (void*)mplSettings, sizeof(settings) );\n\n    // reset all registers to POR values\n    if (MPL_SoftReset()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set the mode\n    else if (MPL_SetMode(settings.mode)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // set over-sampling\n    else if (MPL_SetOversampleRate(settings.oversample)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // enable the flags\n    else if (MPL_EnableEventFlags()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set auto acquisition time step\n    else if (MPL_SetAutoAcquisitionTime(settings.autoAcquisitionTime)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset pressure correction\n    else if (MPL_SetOffsetPressure(settings.pressureOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset altitude correction\n    else if (MPL_SetOffsetAltitude(settings.altitudeOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset temperature correction\n    else if (MPL_SetOffsetTemperature(settings.tempOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // setup FIFO register mode and event count to trigger interrupt\n    else if (MPL_SetFifoMode(settings.fifoMode, settings.fifoWatermark)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set FIFO interrupt and output pin (INT1 or INT2)\n    else if (MPL_SetFifoInterrupt(settings.fifoINTpin)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // goto active state\n    else if (MPL_SetActive()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    return status;\n}\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc)\n{\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sIoFunc = *pIoFunc;\n    initDriverDone = true;\n}\n\nvoid MPL3115_Deinit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        MPL_GotoStandby(); /* skip error management */\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    if (!initDriverDone) return MPL_INIT_ERROR;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    /* initialize the sensor */\n    status = MPL_Init(MPLsettings);\n    if (status != MPL_SUCCESS) initHwDone = false;\n    return status;\n\n}\n\nmpl_status_t MPL_SoftReset()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1, MPL_RST};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // Reset all registers to POR value\n    if (sIoFunc.I2C_Write(wBuf, 2)!= MPL_SUCCESS) return MPL_ERROR;\n    else\n    {\n        // by the end of the boot process the RST bit should be de-asserted to 0 => need to wait before next operation\n        sIoFunc.WaitMsec(10); // 10ms delay\n        return MPL_SUCCESS;\n    }\n}\n\nmpl_status_t MPL_ToggleOneShot()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear OST bit and write it back\n    wBuf[1] = rBuf & ~(MPL_OST);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read again settings, just to be safe\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set OST bit and write it back\n    wBuf[1] = rBuf | MPL_OST;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetID(uint8_t* sensorID)\n{\n    uint8_t wBuf[1] = {WHO_AM_I};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorID != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, sensorID, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetMode (modeMPL_t mode)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set/clear ALT bit\n    switch (mode)\n    {\n    case MPL_MODE_PRESSURE: {\n        wBuf[1] = rBuf & ~( 1 << 7 ); // Clear ALT bit\n        break;\n    }\n    case MPL_MODE_ALTITUDE: {\n        wBuf[1] = rBuf | ( 1 << 7 ); // Set ALT bit\n        break;\n    }\n    case MPL_MODE_TEMPERATURE: {\n        break;\n    }\n    default:\n        return MPL_NOT_SUPPORTED;\n    }\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n    // update the static variable\n    selectedMode = mode;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GotoStandby()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear SBYB bit for entering stand-by mode\n    wBuf[1] = rBuf & ~MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetActive()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set SBYB bit for entering active mode\n    wBuf[1] = rBuf | MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // rate cannot be larger than 7\n    if (sampleRate > 7) sampleRate = 7;\n\n    selectedSampleRate = overSampleFactors[sampleRate];\n    selectedDelay      = overSampleDelays[sampleRate];\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear out old OS bits\n    wBuf[1] = rBuf & ~MPL_OS_MASK;\n    // mask in new OS bits\n    wBuf[1] |= ( sampleRate << MPL_OS_SHIFT );\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t  MPL_SetAutoAcquisitionTime (uint8_t sampleTime)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG2};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // mask in new ST bits. sampleTime cannot be larger than 15 Giving a range of 1s to 9.1 hours\n    wBuf[1] |= (sampleTime > 15) ? 15 : sampleTime;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_EnableEventFlags()\n{\n    uint8_t wBuf[] = {PT_DATA_CFG, 0x07};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_P, pressOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset)\n{\n    uint8_t wBuf[] = {OFF_H, altitudeOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_T, temperatureOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk)\n{\n    uint8_t wBuf[2] = {F_SETUP};\n    wBuf[1] = (fMode << 6) | (fWmrk & MPL_F_WMRKK_MASK);\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & set INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf | (1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read CTRL5 register & Route interrupt to either INT1 or INT2 pin\n    wBuf[0] = MPL_CTRL_REG5;\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    wBuf[1] = (pinINT == FIFO_INT1) ? rBuf | (1 << INT_CFG_FIFO_SHIFT) : rBuf &~(1 << INT_CFG_FIFO_SHIFT);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_DisableFifoInterrupt ()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & disable INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf & ~(1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus)\n{\n    uint8_t wBuf[1] = {F_STATUS};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(fifoStatus != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, fifoStatus, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData)\n{\n    uint8_t wBuf[2] = {REG_STATUS};\n    uint8_t rBuf[5];\n    uint8_t dataReadyFlag,\n    dataReadyRegAddr,\n    bytesToRead = 0;\n    int16_t counter = 0;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorData != NULL);\n\n    /* set the new working mode, if given one */\n\n    if  (( mode > MPL_MODE_TEMPERATURE ) && ( mode < MPL_MODE_CURRENT )) return MPL_INIT_ERROR;\n    else if (( MPL_MODE_CURRENT != mode ) && ( selectedMode != mode ))\n    {\n        // goto standby\n        if (MPL_GotoStandby()!=MPL_SUCCESS) return MPL_ERROR;\n        // set the mode\n        if (MPL_SetMode(mode)!=MPL_SUCCESS) return MPL_ERROR;\n        // goto active state\n        if (MPL_SetActive()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    /* prepare for reading data */\n\n    switch (selectedMode)\n    {\n    case MPL_MODE_PRESSURE:\n    case MPL_MODE_ALTITUDE: {\n        dataReadyFlag     = 1 << MPL_PDR_SHIFT;\n        dataReadyRegAddr  = OUT_P_MSB;\n        bytesToRead       = 3;\n        break;\n    }\n\n    case MPL_MODE_TEMPERATURE: {\n        dataReadyFlag     = 1 << MPL_TDR_SHIFT;\n        dataReadyRegAddr  = OUT_T_MSB;\n        bytesToRead       = 2;\n        break;\n    }\n\n    default:  {}\n    }\n\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // check PDR/PTR bit; if it's not set, toggle OST\n    if (0 == (rBuf[0] & dataReadyFlag))\n    {\n        // toggle the OST bit, causing the sensor to immediately take another reading\n        if (MPL_ToggleOneShot()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    // wait for PDR/PTR bit, which indicates that we have new data\n    while (1)\n    {\n        if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        if ((0==(rBuf[0] & dataReadyFlag)) & ( ++counter > 5 )) return MPL_TIMEOUT;\n        else break;\n        sIoFunc.WaitMsec(100);  // Wait 100ms\n    }\n\n    /* read sensor data */\n\n    wBuf[0] = dataReadyRegAddr;\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, bytesToRead)!=MPL_SUCCESS) return MPL_ERROR;\n\n    switch ( selectedMode )\n    {\n    // pressure value is a Q18.2 right-aligned number in [Pa]\n    case MPL_MODE_PRESSURE:\n        // altitude value is a Q16.4 right-aligned number in [m]\n    case MPL_MODE_ALTITUDE:     {\n        *sensorData = (int32_t) ((rBuf[0] << 16) | (rBuf[1] << 8) | rBuf[2]) >> 4;\n        break;\n    }\n\n    // temperature value is a Q8.4 right-aligned number in [C]\n    case MPL_MODE_TEMPERATURE:  {\n        *sensorData = (int32_t) (((rBuf[0] << 8) | rBuf[1]) >> 4);\n        break;\n    }\n    default:  {}\n    }\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_Dump(uint8_t *sensorReg)\n{\n    uint8_t wBuf= 0;\n    uint8_t rBuf;\n    uint8_t i;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorReg != NULL);\n\n    // read all registers\n    for (i=0; i<45; i++)\n    {\n        if (sIoFunc.I2C_Read(&wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        *sensorReg = rBuf;\n        wBuf++;\n        sensorReg++;\n    }\n    return MPL_SUCCESS;\n}\n"
              }
            }
          }
        },
        "ens210": {
          "libName": "ens210",
          "description": "AMS ENS210 Humidity and Temperature Sensor",
          "type": "Humidity + Temperature Sensor",
          "icon": "",
          "manufacturer": "AMS",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "ENS210TemperatureHumidity",
              "type": "EmbeddedENS210",
              "icon": "EmbeddedTempHumidity.svg",
              "defaultAbility": "readTemperature",
              "defaultTrigger": "temperatureRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(undefined, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTemperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readHumidity",
                  "triggers": [
                    "humidityRead"
                  ],
                  "code": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x43"
                },
                {
                  "name": "tempCalibrationOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedENS210": "ENS210 Temperature/Humidity Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readTemperature": "Read Temperature(C)",
                  "temperatureRead": "Temperature Read",
                  "readHumidity": "Read Humidity(%rh)",
                  "humidityRead": "Humidity Read",
                  "tempCalibrationOffset": "Temperature Calibration Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ens210.h": "#ifndef _ATMO_ENS210_H_\n#define _ATMO_ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_ENS210_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_ENS210_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_ENS210_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_ENS210_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_ENS210_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_ENS210_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    int16_t tempCalibrationOffset;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n} ATMO_ENS210_Config_t;\n\n/**\n * Initialize ENS210 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config);\n\n/**\n * Enable/Disable ENS210 Driver\n *\n * @param[in] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of ENS210 driver\n *\n * @param[out] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct);\n\n#endif\n",
                "ens210_internal.h": "/*\n *****************************************************************************\n * Copyright by ams AG                                                       *\n * All rights are reserved.                                                  *\n *                                                                           *\n * IMPORTANT - PLEASE READ CAREFULLY BEFORE COPYING, INSTALLING OR USING     *\n * THE SOFTWARE.                                                             *\n *                                                                           *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       *\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         *\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS         *\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     *\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT          *\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     *\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     *\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       *\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     *\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      *\n *****************************************************************************\n */\n\n\n#ifndef __ENS210_H_\n#define __ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*! @addtogroup ens210   ENS210 Driver API\n * This module provides the API to operate an ENS210 relative humidity and temperature sensor with I2C interface.\n *\n * Basic steps to operate the sensor are as follows:\n * -# Set Run mode (#ENS210_SensRun_Set)\n * -# Start measurement (#ENS210_SensStart_Set)\n * -# Wait for measurement to complete\n * -# Read measurement (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get)\n *\n * Please refer to ENS210 Reference Driver and Porting Guide for more details on platform porting. In this module, names\n * T and H have been used to refer to temperature and relative humidity respectively to comply with ENS210 datasheet\n * naming convention.\n *\n * Example 1 - Sample application code to measure temperature and relative humidity without error checking\n * -------------------------------------------------------------------------------------------------------\n * @code\n * uint32_t T_Raw, H_Raw;\n * int32_t T_mCelsius, T_mFahrenheit, T_mKelvin, H_Percent;\n *\n * //Set runmode, start measurement, wait, read measurement (for both T and H)\n * ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * ENS210_SensStart_Set(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START);\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n * ENS210_THVal_Get(&T_Raw,&H_Raw);\n *\n * //Convert the raw temperature to milli Kelvin\n * T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n * //Convert the raw temperature to milli Celsius\n * T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n * //Convert the raw temperature to milli Fahrenheit\n * T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n * printf(\"T crc ok = %s\\n\", ENS210_IsCrcOk(T_Raw)  ? \"yes\" : \"no\");\n * printf(\"T valid = %s \\n\", ENS210_IsDataValid(T_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"T = %ld mK %ld mC %ld mF \\n\", T_mKelvin, T_mCelsius, T_mFahrenheit);\n *\n * //Convert the raw relative humidity to milli %\n * H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n * printf(\"H crc ok = %s\\n\", ENS210_IsCrcOk(H_Raw)  ? \"yes\" : \"no\");\n * printf(\"H valid = %s \\n\", ENS210_IsDataValid(H_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"H = %ld m%%\\n\", H_Percent);\n *\n * @endcode\n *\n *\n * Example 2 - Sample application code to measure relative humidity with error checking\n * ------------------------------------------------------------------------------------\n * @code\n * uint32_t H_Raw;\n * int32_t H_Percent;\n * int status;\n * bool i2cOk;\n *\n * i2cOk = true; //Start accumulating I2C transaction errors\n *\n * status = ENS210_SensRun_Set(ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * status = ENS210_SensStart_Set(ENS210_SENSSTART_H_START);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n *\n * status = ENS210_HVal_Get(&H_Raw);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * if( !i2cOk ) {\n *     printf(\"H i2c error\\n\")\n * } else if( !ENS210_IsCrcOk(H_Raw) ) {\n *     printf(\"H crc error\\n\")\n * } else if( !ENS210_IsDataValid(H_Raw) ) {\n *     printf(\"H data invalid\\n\")\n * } else {\n *     //Convert the raw relative humidity to milli %\n *     H_Percent = ENS210_ConvertRawToPercentageH(H_Raw,1000);\n *     //Update the int32_t format specifier (%ld) based on platform word-size\n *     printf(\"H = %ld m%%\\n\", H_Percent);\n * }\n *\n * @endcode\n *\n * @{\n */\n/*****************************************************************************\n * Types/enumerations/variables\n ****************************************************************************/\n\n/*! @brief Status return codes. */\ntypedef enum ens210_status_ {\n    ens210_success = 0,             /*!< Function returned successfully. */\n    ens210_I2C_error = 1,           /*!< I2C Error. */\n    ens210_invalid_ID = 2,          /*!< Invalid ID. */\n    ens210_Tdata_CRC_error = 3,     /*!< CRC error for temperature data. */\n    ens210_Hdata_CRC_error = 4,     /*!< CRC error for humidity data. */\n    ens210_T_invalid_data = 5,      /*!< Temperature Data is invalid. */\n    ens210_H_invalid_data = 6,      /*!< Humidity Data is invalid. */\n    ens210_wrong_parameter = 7,     /*!< Wrong Parameter entered. */\n    ens210_noinit = 8               /*!< ENS210 was not initialized. */\n} ens210_status_t;\n\n/*! @brief Measurement mode of Sensor */\nenum measurement_mode {\n    mode_TH = 0,        /*!< ENS210 set to measure both temperature and humidity. */\n    mode_Tonly = 1,     /*!< ENS210 set to measure temperature only. */\n    mode_Honly = 2      /*!< ENS210 set to measure humidity only. */\n};\n\n/*! ENS210 os-free driver version info */\n#define ENS210_OSFREE_DRIVER_VERSION            2\n\n/*! ENS210 T and H conversion time in milliseconds. Refer to ENS210 data sheet for timing information. */\n#define ENS210_T_H_CONVERSION_TIME_MS           130\n\n/*! ENS210 T conversion time in milliseconds */\n#define ENS210_T_CONVERSION_TIME_MS             110\n\n/*! ENS210 Booting time in milliseconds. */\n#define ENS210_BOOTING_TIME_MS                  10\n\n/*! ENS210 Reset time in milliseconds. */\n#define ENS210_RESET_WAIT_TIME_MS               10\n\n/*! ENS210 I2C slave address */\n#define ENS210_I2C_SLAVE_ADDRESS                (uint8_t)0x43\n\n/*! ENS210 SysCtrl register: Low power enable */\n#define ENS210_SYSCTRL_LOWPOWER_ENABLE          (1 << 0)\n/*! ENS210 SysCtrl register: Low power disable */\n#define ENS210_SYSCTRL_LOWPOWER_DISABLE         (0 << 0)\n/*! ENS210 SysCtrl register: Reset enable */\n#define ENS210_SYSCTRL_RESET_ENABLE             (1 << 7)\n/*! ENS210 SysCtrl register: Reset disable */\n#define ENS210_SYSCTRL_RESET_DISABLE            (0 << 7)\n\n/*! ENS210 SysStat register: Standby or Booting mode */\n#define ENS210_SYSSTAT_MODE_STANDBY             (0 << 0)\n/*! ENS210 SysStat register: Active mode */\n#define ENS210_SYSSTAT_MODE_ACTIVE              (1 << 0)\n\n\n/*! ENS210 SensRun register: temperature single shot mode */\n#define ENS210_SENSRUN_T_MODE_SINGLE_SHOT       (0 << 0)\n/*! ENS210 SensRun register: temperature continuous mode */\n#define ENS210_SENSRUN_T_MODE_CONTINUOUS        (1 << 0)\n/*! ENS210 SensRun register: relative humidity single shot mode */\n#define ENS210_SENSRUN_H_MODE_SINGLE_SHOT       (0 << 1)\n/*! ENS210 SensRun register: relative humidity continuous mode */\n#define ENS210_SENSRUN_H_MODE_CONTINUOUS        (1 << 1)\n\n/*! ENS210  SensStart register: T sensor start */\n#define ENS210_SENSSTART_T_START                (1 << 0)\n/*! ENS210  SensStart register: H sensor start */\n#define ENS210_SENSSTART_H_START                (1 << 1)\n\n/*! ENS210  SensStop register: T sensor stop */\n#define ENS210_SENSSTOP_T_STOP                  (1 << 0)\n/*! ENS210  SensStop register: H sensor stop */\n#define ENS210_SENSSTOP_H_STOP                  (1 << 1)\n\n/*! ENS210  SensStat register: T sensor idle */\n#define ENS210_SENSSTAT_T_STAT_IDLE             (0 << 0)\n/*! ENS210  SensStat register: T sensor active */\n#define ENS210_SENSSTAT_T_STAT_ACTIVE           (1 << 0)\n/*! ENS210  SensStat register: H sensor idle */\n#define ENS210_SENSSTAT_H_STAT_IDLE             (0 << 1)\n/*! ENS210  SensStat register: H sensor active */\n#define ENS210_SENSSTAT_H_STAT_ACTIVE           (1 << 1)\n\n/* wrapper for the I2C write, I2C read and wait functions needed by the sensor driver */\n/* it is expected that the I2C_Read and I2C_Write functions return 0 if the I2C transaction is successful */\ntypedef struct _ens210_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);  /*!< External I2C read function */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);  /*!< External I2C write function */\n    void      (*WaitMsec)(uint32_t millisec); /*!< Wait function in milliseconds */\n} ens210_IoFunc_t, *pens210_IoFunc_t;\n\n/*! @brief    ENS210 ID block structure */\ntypedef struct ENS210_Ids_s\n{\n    uint16_t    partId;             /*!< Part ID */\n    uint8_t     uId[8];             /*!< Unique Identifier 8 bytes */\n} ENS210_Ids_t;\n\n/*! @brief Structure of measurement data. */\ntypedef struct ens210_meas_data_s\n{\n    int32_t T_Celsius;              /*!< Temperature in Celsius */\n    int32_t T_Fahrenheit;           /*!< Temperature in Fahrenheit */\n    int32_t T_Kelvin;               /*!< Temperature in Kelvin */\n    int32_t T_mCelsius;             /*!< Temperature in milliCelsius */\n    int32_t T_mFahrenheit;          /*!< Temperature in milliFahrenheit */\n    int32_t T_mKelvin;              /*!< Temperature in milliKelvin */\n    int32_t H_Percent;              /*!< Relative Humidity to % */\n    int32_t H_mPercent;             /*!< Relative Humidity to milli% */\n} ens210_meas_data_t;\n\n/****************************************************************************\n * Function Prototypes\n ****************************************************************************/\n\n/*!\n * @brief   Initialize ENS210 driver.\n * @param   pIoFunc     :   Pointer to a structure of external functions or values\n */\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc);\n\n/*!\n * @brief   De-initialize ENS210 driver.\n */\nvoid ENS210_Deinit_Driver();\n\n/*!\n * @brief   Initialize ENS210 hardware.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_Init_Hw(void);\n\n/*!\n * @brief   Set ENS210 SysCtrl register; enabling reset and/or low power.\n * @param   sysCtrl     :   Mask composed of  ENS210_SYSCTRL_xxx macros.\n * @return  The return status value (0 for success)\n *  */\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysCtrl register.\n * @param   sysCtrl     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysStat register.\n * @param   sysStat     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat);\n\n/*!\n * @brief   Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\n * @param   sensRun     :   Mask composed of ENS210_SENSRUN_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun);\n\n/*!\n * @brief   Get ENS210 SensRun register.\n * @param   sensRun     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun);\n\n/*!\n * @brief   Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\n * @param   sensStart   :  Mask composed of ENS210_SENSSTART_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart);\n\n/*!\n * @brief   Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\n * @param   sensStop    :   Mask composed of ENS210_SENSSTOP_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop);\n\n/*!\n * @brief   Get ENS210 SensStat register.\n * @param   sensStat    :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat);\n\n/*!\n * @brief   Get ENS210 TVal register; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * Use ENS210_ConvertRawToXXX to convert raw data to standard units.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_TVal_Get(uint32_t *traw);\n\n/*!\n * @brief   Get ENS210 HVal register; raw measurement data as well as CRC and valid indication.\n * @param   hraw         :   Pointer to receive value of register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_HVal_Get(uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 TVal and HVal registers; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of TVal register. Must not be null.\n * @param   hraw         :   Pointer to receive value of HVal register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 Part ID and UID.\n * @param   ids         :   Pointer to receive ids. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If this function returns an error, it is suggested to reset the device to bring it to a known state.\n */\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids);\n\n/*!\n * @brief   Get ENS210 temperature and humidity measurements\n * @param   meas_mode    :   Measurement mode\n * @param   results      :   Pointer to the result structure\n * @return  The return status value (0 for success)\n * @note\n * mode = 0: temperature and humidity\\n\n * mode = 1: temperature only\\n\n * mode = 2: humidity only\n */\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results);\n\n/*!\n * @}\n */\n\n#endif /* __ENS210_H_ */\n\n"
              },
              "objects": {
                "ens210.c": "#include \"ens210.h\"\n#include \"ens210_internal.h\"\n\ntypedef struct {\n    ATMO_ENS210_Config_t config;\n    bool configured;\n} ATMO_ENS210_Priv_Config;\n\nstatic ATMO_ENS210_Priv_Config _ATMO_ENS210_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_ENS210_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool _ATMO_ENS210_Enabled = true;\n\nstatic uint8_t ATMO_ENS210_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t ATMO_ENS210_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_ENS210_SetConfiguration(config);\n    }\n    else\n    {\n        _ATMO_ENS210_config.configured = false;\n    }\n\n    ens210_IoFunc_t io;\n    io.I2C_Read = ATMO_ENS210_I2CRead_Simple;\n    io.I2C_Write = ATMO_ENS210_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    ENS210_Init_Driver(&io);\n    ENS210_Init_Hw();\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled)\n{\n    _ATMO_ENS210_Enabled = enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled)\n{\n    *enabled = _ATMO_ENS210_Enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_ENS210_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n    memcpy( &_ATMO_ENS210_config.config, config, sizeof(ATMO_ENS210_Config_t) );\n    _ATMO_ENS210_config.configured = true;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL || !_ATMO_ENS210_config.configured )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_ENS210_config.config, sizeof(ATMO_ENS210_Config_t));\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = results.T_Celsius + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_Percent;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = (results.T_mCelsius / 1000.0) + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_mPercent / 1000.0;\n\n    return ATMO_ENS210_Status_Success;\n}",
                "ens210_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file\n * This is the source file for the temperature and humidity sensor ENS210 driver.\n */\n\n#include \"ens210_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/*****************************************************************************\n * Private macros and functions\n ****************************************************************************/\n/* Register addresses */\n#define ENS210_REG_PART_ID     0x00\n#define ENS210_REG_UID         0x04\n#define ENS210_REG_SYS_CTRL    0x10\n#define ENS210_REG_SYS_STAT    0x11\n#define ENS210_REG_SENS_RUN    0x21\n#define ENS210_REG_SENS_START  0x22\n#define ENS210_REG_SENS_STOP   0x23\n#define ENS210_REG_SENS_STAT   0x24\n#define ENS210_REG_T_VAL       0x30\n#define ENS210_REG_H_VAL       0x33\n\n/** Mask to extract 16-bit data from raw T and H values */\n#define ENS210_T_H_MASK        0xFFFFU\n\n/** Simplification macro, implementing integer division with simple rounding to closest number\n *  It supports both positive and negative numbers, but ONLY positive divisors */\n#define IDIV(n,d)              ((n)>0 ? ((n)+(d)/2)/(d) : ((n)-(d)/2)/(d))\n\n#define CRC7WIDTH              7     //7 bits CRC has polynomial of 7th order (has 8 terms)\n#define CRC7POLY               0x89  //The 8 coefficients of the polynomial\n#define CRC7IVEC               0x7F  //Initial vector has all 7 bits high\n\n#define DATA7WIDTH             17\n#define DATA7MASK              ((1UL << DATA7WIDTH) - 1)  //0b 1 1111 1111 1111 1111\n#define DATA7MSB               (1UL << (DATA7WIDTH - 1))  //0b 1 0000 0000 0000 0000\n\n/** When the ENS210 is soldered a correction on T needs to be applied (see application note).\n *  Typically the correction is 50mK. Units for raw T is 1/64K. */\n#define ENS210_TRAW_SOLDERCORRECTION  (50*64/1000)\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\n\nstatic ens210_IoFunc_t sENS210_Func;\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\n\n/*****************************************************************************\n * Private functions prototypes\n ****************************************************************************/\n\n/*\n * @brief   Compute the CRC7 results.\n * @param   val   :   the value\n * @return  The CRC7 computed result\n */\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val);\n\n/*\n * @brief   Verify the CRC of the raw temperature or relative humidity.\n * @param   raw         :  Raw temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Success,  False - Failure.\n * @note    This function can be used on raw T as well as raw H data (since they use the same format and CRC).\n */\nstatic bool ENS210_IsCrcOk(uint32_t raw);\n\n/*\n * @brief   Verify data validity of the raw temperature or relative humidity.\n * @param   raw         :  Raw  temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Valid,  False - Invalid.\n */\nstatic bool ENS210_IsDataValid(uint32_t raw);\n\n/*\n * @brief   Converts a raw temperature value into Kelvin.\n *          The output value is in Kelvin multiplied by parameter \"multiplier\".\n * @param   traw        :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier  :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Kelvin.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Celsius.\n *          The output value is in Celsius multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Celsius.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Fahrenheit.\n *          The output value is in Fahrenheit multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted temperature\n * @return  The temperature value in 1/multiplier Fahrenheit.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw relative humidity value into human readable format.\n * @param   hraw         :   The relative humidity value in the raw format (#ENS210_HVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted relative humidity.\n * @return  The converted relative humidity value\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier);\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\n//Compute the CRC-7 of 'val' (which should only have 17 bits)\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val)\n{\n    //Setup polynomial\n    uint32_t pol= CRC7POLY;\n\n    //Align polynomial with data\n    pol = pol << (DATA7WIDTH-CRC7WIDTH-1);\n\n    //Loop variable (indicates which bit to test, start with highest)\n    uint32_t bit = DATA7MSB;\n\n    //Make room for CRC value\n    val = val << CRC7WIDTH;\n    bit = bit << CRC7WIDTH;\n    pol = pol << CRC7WIDTH;\n\n    //Insert initial vector\n    val |= CRC7IVEC;\n\n    //Apply division until all bits done\n    while( bit & (DATA7MASK<<CRC7WIDTH) )\n    {\n        if( bit & val )\n        {\n            val ^= pol;\n        }\n        bit >>= 1;\n        pol >>= 1;\n    }\n    return val;\n}\n\n//Verify the CRC\nstatic bool ENS210_IsCrcOk(uint32_t raw)\n{\n    uint32_t crc, data;\n\n    assert(raw <= 0xffffffUL);\n\n    //Extract 7-bit CRC(Bit-17 to Bit-23)\n    crc =  (raw >> 17) & 0x7F;\n\n    //Get the raw T/H and data valid indication.\n    data =  raw & 0x1ffff;\n\n    return ENS210_ComputeCRC7(data) == crc;\n}\n\n//Check the Data Valid Bit\nstatic bool ENS210_IsDataValid(uint32_t raw)\n{\n    assert(raw <= 0xffffffUL);\n\n    //Bit-16 is data valid bit. It will be set if data is valid\n    return (raw & (1UL << 16)) != 0;\n}\n\n//Convert raw temperature to Kelvin\n//The output value is in Kelvin multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*K\n    //where m is the multiplier, R the raw value and K is temperature in Kelvin.\n    //K=R/64 (since raw has format 10.6).\n    //m*K =  m*R/64\n    return IDIV(t*multiplier, 64);\n}\n\n//Convert raw temperature to Celsius\n//The output value is in Celsius multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*C\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use C=K-273.15 and K=R/64 (since raw has format 10.6).\n    //m*C = m*(K-273.15) = m*K - 27315*m/100 = m*R/64 - 27315*m/100\n\n    return IDIV(t*multiplier, 64) - IDIV(27315L*multiplier, 100);\n}\n\n//Convert raw temperature to Fahrenheit\n//The output value is in Fahrenheit multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*F\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use F=1.8*(K-273.15)+32 and K=R/64 (since raw has format 10.6).\n\n    //m*F = m*(1.8*(K-273.15)+32) = m*(1.8*K-273.15*1.8+32) = 1.8*m*K-459.67*m = 9*m*K/5 - 45967*m/100 = 9*m*R/320 - 45967*m/100\n    return IDIV(9*multiplier*t, 320) - IDIV(45967L*multiplier, 100);\n\n    //The first multiplication stays below 32 bits (tRaw:16, multiplier:11, 9:4)\n    //The second  multiplication stays below 32 bits (multiplier:10, 45967:16)\n}\n\n//Convert raw relative humidity to readable format\n//The output value is in % multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier)\n{\n    int32_t h;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw relative humidity\n    h = hraw & ENS210_T_H_MASK;\n\n    //As raw format is 7.9, to obtain the relative humidity, it must be divided by 2^9\n    return IDIV(h*multiplier, 512);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n// wrap the low level function (I2C write, I2C read, WaitMsec) required by ENS210 driver\n// this function does not initialize the HW\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc){\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sENS210_Func = *pIoFunc;\n    initDriverDone = true;\n}\n\n// De-initialize the driver\nvoid ENS210_Deinit_Driver(){\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\n// Initialize ENS210 hardware\nens210_status_t ENS210_Init_Hw(void)\n{\n    ens210_status_t status = ens210_success;\n\n    if (!initDriverDone) return ens210_noinit;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    //Reset the sensor\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_RESET_ENABLE | ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_status;\n\n    //Wait for ENS210 to complete reset\n    sENS210_Func.WaitMsec(ENS210_RESET_WAIT_TIME_MS);\n\n    //Set the run mode of sensors\n    status = ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n    if (status != ens210_success) goto return_status;\n\n    return_status:\n    if (status != ens210_success) initHwDone = false;\n    return status;\n}\n\n//Set ENS210 SysCtrl register; enabling reset and/or low power\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL, sysCtrl};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sysCtrl & ~(ENS210_SYSCTRL_LOWPOWER_ENABLE | ENS210_SYSCTRL_RESET_ENABLE)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof (wBuf));\n}\n\n//Get ENS210 SysCtrl register\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysCtrl != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysCtrl, sizeof (*sysCtrl));\n}\n\n//Get ENS210 SysStat register.\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysStat, sizeof (*sysStat));\n}\n\n//Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN, sensRun};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensRun & ~(ENS210_SENSRUN_T_MODE_CONTINUOUS | ENS210_SENSRUN_H_MODE_CONTINUOUS)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensRun register\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensRun != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensRun, sizeof *sensRun);\n}\n\n//Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_START, sensStart};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStart & ~(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STOP, sensStop};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStop & ~(ENS210_SENSSTOP_T_STOP | ENS210_SENSSTOP_H_STOP)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensStat register.\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensStat, sizeof *sensStat);\n}\n\n//Get ENS210 TVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_TVal_Get(uint32_t *traw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(traw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n\n    return status;\n}\n\n//Get ENS210 HVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_HVal_Get(uint32_t *hraw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_H_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(hraw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *hraw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n\n    return status;\n}\n\n//Get ENS210 TVal and Hval registers; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw)\n{\n    uint8_t rBuf[6];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert((traw != NULL) && (hraw != NULL));\n\n    // Read 6 bytes starting from ENS210_REG_T_VAL\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n    *hraw = ((uint32_t)rBuf[5]) << 16 | ((uint32_t)rBuf[4]) << 8 | (uint32_t)rBuf[3];\n\n    return status;\n}\n\n// Get ENS210 Part ID and UID.\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids)\n{\n    uint8_t rBuf[12];\n    uint8_t wBuf[] = {ENS210_REG_PART_ID};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(ids != NULL);\n\n    // Special procedure needed to read ID's: put device in high power (see datasheet)\n    // Set the system in Active mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_DISABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Wait for sensor to go to active mode\n    sENS210_Func.WaitMsec(ENS210_BOOTING_TIME_MS);\n\n    // Get the id's\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n    if (status != ens210_success) goto return_error_status;\n\n    // Copy id's (hw gives partid in little-endian format)\n    ids->partId = ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n    memcpy(&ids->uId[0], &rBuf[4], 8);\n\n    // Go back to low power mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Signal success\n    return status;\n\n    return_error_status:\n    // Make an attempt to restore low-power\n    ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    // Return original I2C error\n    return status;\n}\n\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results){\n    ens210_status_t status;\n    uint8_t meas_status;\n    uint32_t T_Raw = 0, H_Raw = 0;\n    uint32_t conversion_time_ms = 0;\n    uint8_t start_meas = 0;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(results != NULL);\n\n    switch (meas_mode){\n    case mode_TH :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START;\n        break;\n    case mode_Tonly :\n        conversion_time_ms = ENS210_T_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START;\n        break;\n    case mode_Honly :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_H_START;\n        break;\n    default :\n        return ens210_wrong_parameter;\n        break;\n    }\n\n    //check that the previous measurement is completed\n    status = ENS210_SensStat_Get(&meas_status);\n    if (status != ens210_success){\n        return status;\n    }\n    if(meas_status != 0){\n        // trying to start a measurement too early!\n        sENS210_Func.WaitMsec(conversion_time_ms);\n    }\n\n    //Start the measurement\n    status = ENS210_SensStart_Set(start_meas);\n    if(status != ens210_success){\n        //Start of measurement failed.\n        return status;\n    }\n\n    // wait for the measurement to be completed\n    sENS210_Func.WaitMsec(conversion_time_ms);\n\n    if (meas_mode == mode_TH){\n        //Get the temperature and humidity raw value\n        status = ENS210_THVal_Get(&T_Raw, &H_Raw);\n    }\n    else if (meas_mode == mode_Tonly){\n        status = ENS210_TVal_Get(&T_Raw);\n    }\n    else if (meas_mode == mode_Honly){\n        status = ENS210_HVal_Get(&H_Raw);\n    }\n    if(status != ens210_success){\n        //Getting T and/or H values failed\n        return status;\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Tonly)){\n        // Verify the temperature raw value\n        if(!ENS210_IsCrcOk(T_Raw))    {\n            return ens210_Tdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(T_Raw)){\n            return ens210_T_invalid_data;\n        }\n        else {\n            //Convert the raw temperature value to Kelvin\n            results->T_Kelvin = ENS210_ConvertRawToKelvin(T_Raw, 1);\n            //Convert the raw temperature value to Celsius\n            results->T_Celsius = ENS210_ConvertRawToCelsius(T_Raw, 1);\n            //Convert the raw temperature value to Fahrenheit\n            results->T_Fahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1);\n            //Convert the raw temperature value to milli Kelvin\n            results->T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n            //Convert the raw temperature value to milli Celsius\n            results->T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n            //Convert the raw temperature value to milli Fahrenheit\n            results->T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n        }\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Honly)){\n        //Verify the relative humidity raw value\n        if(!ENS210_IsCrcOk(H_Raw)){\n            return ens210_Hdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(H_Raw)){\n            return ens210_H_invalid_data;\n        }\n        else {\n            //Convert the raw relative humidity to %\n            results->H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1);\n            //Convert the raw relative humidity to milli%\n            results->H_mPercent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n        }\n    }\n    return ens210_success;\n}\n"
              }
            }
          }
        },
        "ccs811": {
          "libName": "ccs811",
          "manufacturer": "AMS",
          "description": "Digital Gas Sensor",
          "type": "Digital Gas Sensor",
          "icon": "",
          "image": "ccs811.jpg",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "CCS811AirQuality",
              "type": "EmbeddedCCS811",
              "icon": "EmbeddedAirQuality.svg",
              "defaultAbility": "readTVOC",
              "defaultTrigger": "TVOCRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(undefined, operatingMode);\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTVOC",
                  "triggers": [
                    "TVOCRead"
                  ],
                  "code": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readCO2",
                  "triggers": [
                    "CO2Read"
                  ],
                  "code": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x5A"
                },
                {
                  "name": "operatingMode",
                  "input": "number",
                  "value": "1"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedCCS811": "CCS811 Air Quality Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readTVOC": "Read TVOC (ppb)",
                  "readCO2": "Read CO2 (ppm)",
                  "TVOCRead": "TVOC Read",
                  "CO2Read": "CO2 Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ccs811.h": "#ifndef _ATMO_CCS811_H_\r\n#define _ATMO_CCS811_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\n\r\ntypedef enum {\r\n    ATMO_CCS811_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_CCS811_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_CCS811_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_CCS811_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_CCS811_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_CCS811_Status_t;\r\n\r\ntypedef struct {\r\n\t//Mode 0 = Idle\r\n\t//Mode 1 = read every 1s\r\n\t//Mode 2 = every 10s\r\n\t//Mode 3 = every 60s\r\n\t//Mode 4 = RAW mode\r\n\tuint8_t operatingMode;\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_CCS811_Config_t;\r\n\r\n\r\n/**\r\n * Initialize CCS811 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable CCS811 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of CCS811 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Set environmental data for more accurate readings\r\n *\r\n * @param[in] humidity - Pct from 0.0 to 100.0\r\n * @param[in] temperature - Degrees C\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnvironmentalData(float humidity, float temperature);\r\n\r\n/**\r\n * Get Total Volatile Organic Compounds (TVOC) Reading\r\n *\r\n * @param[out] tvoc - TVOC reading in PPB\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc);\r\n\r\n/**\r\n * Get total CO2 Reading in ppm\r\n *\r\n * @param[out] CO2\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2);\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality);\r\n\r\n\r\n#endif\r\n",
                "ccs811_internal.h": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*!\r\n * @file\r\n * This is the header file for the air quality sensor CCS811 driver.\r\n */\r\n\r\n#ifndef CCS811_H_\r\n#define CCS811_H_\r\n\r\n/*!\r\n * @addtogroup ccs811 CCS811 air quality sensor\r\n * This module provides the API to control and monitor the CCS811 air quality sensor through an I2C interface.\r\n *\r\n * The basic steps to operate the CCS811 are as follows:\r\n * -# Initialize the driver with callback functions (#CCS811_Init_Driver)\r\n * -# Initialize the hardware (#CCS811_Init_Hw)\r\n * -# Check data availability (#CCS811_dataAvailable)\r\n * -# Trigger all data acquisition (#CCS811_readAlgorithmResults)\r\n * -# Read the relevant data (for example #CCS811_getCO2)\r\n * -# If the CCS811 is not needed anymore, de-initialize the driver (#CCS811_Deinit_Driver). The CCS811 will\r\n * be switched off. It allows to eventually release shared resources.\r\n *\r\n * Example - Sample application code to set CCS811 without error management\r\n * ------------------------------------------------------------------------\r\n * @code\r\n * \\#include \"CCS811.h\"\r\n *\r\n * CCS811_fct_t ccs811_fct;\r\n * uint8_t ready;\r\n * uint16_t uCO2;\r\n *\r\n * ccs811_fct.connect_hw = Ccs811_Connect;       // callback function to activate CCS811 hardware resource\r\n * ccs811_fct.disconnect_hw = Ccs811_Disconnect; // callback function to deactivate CCS811 hardware resource\r\n * ccs811_fct.I2C_Read = I2c_Read;               // callback function for I2C read\r\n * ccs811_fct.I2C_Write = I2c_Write;             // callback function for I2C write\r\n * ccs811_fct.WaitMsec = WaitMs;                 // wait callback function (in ms)\r\n *\r\n * CCS811_Init_Driver(&ccs811_fct);\r\n * CCS811_Init_Hw();\r\n * // check new data availability\r\n * CCS811_dataAvailable(&ready);\r\n * if (ready == 1) {\r\n *     CCS811_readAlgorithmResults();\r\n *     uCO2 = CCS811_getCO2();\r\n *     printf(\"The current CO2 value is: %d\\n\", uCO2);\r\n * }\r\n * [..]\r\n * // if the CCS811 is not needed anymore, the driver can be de-initialized\r\n * printf(\"Deinitialize CCS811 (it will be turned off)\\n\");\r\n * CCS811_Deinit_Driver();\r\n *\r\n * @endcode\r\n * @{\r\n */\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include <stdbool.h>\r\n\r\n#define CCS811_I2C_ADDRESS              0x5A\r\n\r\n/* Register addresses */\r\n#define CCS811_STATUS                   0x00\r\n#define CCS811_MEAS_MODE                0x01\r\n#define CCS811_ALG_RESULT_DATA          0x02\r\n#define CCS811_RAW_DATA                 0x03\r\n#define CCS811_ENV_DATA                 0x05\r\n#define CCS811_NTC                      0x06\r\n#define CCS811_THRESHOLDS               0x10\r\n#define CCS811_BASELINE                 0x11\r\n#define CCS811_HW_ID                    0x20\r\n#define CCS811_HW_VERSION               0x21\r\n#define CCS811_FW_BOOT_VERSION          0x23\r\n#define CCS811_FW_APP_VERSION           0x24\r\n#define CCS811_ERROR_ID                 0xE0\r\n#define CCS811_APP_START                0xF4\r\n#define CCS811_SW_RESET                 0xFF\r\n#define CCS811_INTERRUPT_DRIVEN         0x8\r\n#define CCS811_THRESHOLDS_ENABLED       0x4\r\n\r\n/*! @brief Status return codes. */\r\ntypedef enum _CCS811_status\r\n{\r\n    CCS811_SUCCESS,        /*!< Success */\r\n    CCS811_ID_ERROR,       /*!< Bad hardware identifier */\r\n    CCS811_I2C_ERROR,      /*!< I2C read/write error */\r\n    CCS811_INTERNAL_ERROR, /*!< Internal hardware error */\r\n    CCS811_NOINIT_ERROR,   /*!< Hardware or driver not initialized */\r\n    CCS811_GENERIC_ERROR   /*!< Generic error (settings not allowed) */\r\n} CCS811_status;\r\n\r\n/*! @brief Structure of external functions or values. */\r\ntypedef struct _CCS811_fct_t\r\n{\r\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize); /*!< External I2C read function */\r\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize); /*!< External I2C write function */\r\n    void (*WaitMsec)(uint32_t tms); /*!< Wait function in milliseconds */\r\n} CCS811_fct_t, *ptCCS811_fct_t;\r\n\r\n/*!\r\n * @brief Initialize CCS811 driver.\r\n *\r\n * @param FCT Pointer to a structure of external functions or values\r\n */\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT);\r\n\r\n/*!\r\n * @brief De-initialize CCS811 driver.\r\n *\r\n */\r\nvoid CCS811_Deinit_Driver();\r\n\r\n/*!\r\n * @brief Initialize CCS811 hardware.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_Init_Hw(void);\r\n\r\n/*!\r\n * @brief Read algorithm results.\r\n * @note Update the total volatile organic compounds (TVOC) in parts per billion (PPB) and the CO2 value.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readAlgorithmResults(void);\r\n\r\n/*!\r\n * @brief Check if error bit is set.\r\n *\r\n * @param  StatusError Pointer to error status bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError);\r\n\r\n/*!\r\n * @brief Check if data is available.\r\n * @note Based on DATA_READ flag in the status register.\r\n *\r\n * @param  value Pointer to available data bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_dataAvailable(uint8_t* value);\r\n\r\n/*!\r\n * @brief Check if APP_VALID is set.\r\n * @note Based on APP_VALID flag in the status register.\r\n *\r\n * @param  value Pointer to APP_VALID bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_appValid(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the error register value.\r\n * @note Based on ERROR_ID register.\r\n *\r\n * @param  value Pointer to error value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  baseline Pointer to baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline);\r\n\r\n/*!\r\n * @brief Set the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  input Baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setBaseline(uint16_t input);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupts.\r\n * @note It clears/sets the nINT signal.\r\n *\r\n * @param  fct Interrupt mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setInterrupts(uint8_t fct);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupt thresholds.\r\n *\r\n * @param  fct Threshold mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setThresholds(uint8_t fct);\r\n\r\n/*!\r\n * @brief Set the drive mode.\r\n * @note\r\n * Mode 0 = Idle\\n\r\n * Mode 1 = read every 1s\\n\r\n * Mode 2 = every 10s\\n\r\n * Mode 3 = every 60s\\n\r\n * Mode 4 = RAW mode\r\n *\r\n * @param  mode Drive mode\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setDriveMode(uint8_t mode);\r\n\r\n/*!\r\n * @brief Set environmental data.\r\n * @note\r\n * Given a temperature and humidity, use these data for better compensation.\r\n *\r\n * @param  relativeHumidity Relative humidity, value within [0,100]\r\n * @param  temperature Temperature (Celsius), value within [-25,+50]\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature);\r\n\r\n/*!\r\n * @brief Set ref resistance.\r\n *\r\n * @param  input Ref resistance\r\n */\r\nvoid CCS811_setRefResistance(float input);\r\n\r\n/*!\r\n * @brief Read NTC.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readNTC(void);\r\n\r\n/*!\r\n * @brief Get Total Volatile Organic Compound (TVOC) value.\r\n *\r\n * @return TVOC value (0ppb to 1187ppb)\r\n */\r\nuint16_t CCS811_getTVOC(void);\r\n\r\n/*!\r\n * @brief Get the equivalent CO2 value.\r\n *\r\n * @return eCO2 value (400ppm to 8192ppm)\r\n */\r\nuint16_t CCS811_getCO2(void);\r\n\r\n/*!\r\n * @brief Get resistance value.\r\n *\r\n * @return Resistance value\r\n */\r\nfloat CCS811_getResistance(void);\r\n\r\n/*!\r\n * @brief Get temperature value.\r\n *\r\n * @return Temperature value (Celsius)\r\n */\r\nfloat CCS811_getTemperature(void);\r\n\r\n/*! @}*/\r\n\r\n#endif /* CCS811_H_ */\r\n"
              },
              "objects": {
                "ccs811.c": "#include \"ccs811.h\"\r\n#include \"ccs811_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n#define CCS811_TVOC_MAX_PPB (1187)\r\n\r\n\r\ntypedef struct {\r\n    ATMO_CCS811_Config_t config;\r\n    bool configured;\r\n} ATMO_CCS811_Priv_Config;\r\n\r\nstatic ATMO_CCS811_Priv_Config _ATMO_CCS811_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool _ATMO_CCS811_Enabled = true;\r\n\r\nstatic uint8_t ATMO_CCS811_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t ATMO_CCS811_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config)\r\n{\r\n\r\n    CCS811_fct_t io;\r\n    io.I2C_Read = ATMO_CCS811_I2CRead_Simple;\r\n    io.I2C_Write = ATMO_CCS811_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    CCS811_Init_Driver(&io);\r\n\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n        _ATMO_CCS811_config.configured = false;\r\n    }\r\n\r\n    if( CCS811_Init_Hw() != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    // The configuration has to be set before the Init_HW routine is called\r\n    // But the Init_HW routine resets the device\r\n    // So, we need to just set the configuration one more time after this reset\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled)\r\n{\r\n    _ATMO_CCS811_Enabled = enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = _ATMO_CCS811_Enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    memcpy( &_ATMO_CCS811_config.config, config, sizeof(ATMO_CCS811_Config_t) );\r\n    _ATMO_CCS811_config.configured = true;\r\n\r\n    if( CCS811_setDriveMode(config->operatingMode) != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_CCS811_config.configured )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_CCS811_config.config, sizeof(ATMO_CCS811_Config_t));\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*tvoc = CCS811_getTVOC();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*co2 = CCS811_getCO2();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    \r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*airQuality = (CCS811_getTVOC() * 100.0) / CCS811_TVOC_MAX_PPB;\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n",
                "ccs811_internal.c": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*!\r\n * @file\r\n * This is the source file for the air quality sensor CCS811 driver.\r\n */\r\n\r\n#include \"ccs811_internal.h\"\r\n#include <math.h>\r\n#include <stdbool.h>\r\n#include <assert.h>\r\n\r\n/*****************************************************************************\r\n * Variables\r\n ****************************************************************************/\r\nstatic CCS811_fct_t FCT_CCS811;\r\nstatic bool initDriverDone = false;\r\nstatic bool initHwDone = false;\r\n\r\n/* air quality values obtained from the sensor */\r\nstatic float refResistance;\r\nstatic float resistance = 10000;\r\nstatic uint16_t tVOC = 0;\r\nstatic uint16_t CO2 = 0;\r\nstatic uint16_t vrefCounts = 0;\r\nstatic uint16_t ntcCounts = 0;\r\nstatic float temperature = 0;\r\n\r\n/*****************************************************************************\r\n * Static functions\r\n ****************************************************************************/\r\n\r\n/*\r\n * @brief Read a CCS811 register.\r\n *\r\n * @param  Address of the register to read\r\n * @param  Pointer to the read value\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_readRegister(uint8_t offset, uint8_t* outputPointer)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, 1);\r\n}\r\n\r\n/*\r\n * @brief Read several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to read\r\n * @param  Pointer to the read values\r\n * @param  Number of consecutive registers to read\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiReadRegister(uint8_t offset, uint8_t *outputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, length);\r\n}\r\n\r\n/*\r\n * @brief Write to a CCS811 register.\r\n *\r\n * @param  Address of the register to write to\r\n * @param  Value to write\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_writeRegister(uint8_t offset, uint8_t dataToWrite)\r\n{\r\n\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    cmd[1] = dataToWrite;\r\n\r\n    return FCT_CCS811.I2C_Write(cmd, 2);\r\n}\r\n\r\n/*\r\n * @brief Write to several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to write to\r\n * @param  Pointer to the values to be written\r\n * @param  Number of consecutive registers to write to\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiWriteRegister(uint8_t offset, uint8_t *inputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[length+1];\r\n    cmd[0] = offset;\r\n    for( uint32_t i = 0; i < length; i++ ) //This waits > 1ms @ 80MHz clock\r\n    {\r\n        cmd[1+i] = inputPointer[i];\r\n    }\r\n    return FCT_CCS811.I2C_Write(cmd, length+1);\r\n}\r\n\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT)\r\n{\r\n    assert((FCT != NULL) &&\r\n            (FCT->I2C_Read != NULL) &&\r\n            (FCT->I2C_Write != NULL) &&\r\n            (FCT->WaitMsec != NULL));\r\n    FCT_CCS811 = *FCT;\r\n    initDriverDone = true;\r\n}\r\n\r\nvoid CCS811_Deinit_Driver()\r\n{\r\n    /* Deinit driver */\r\n    initDriverDone = false;\r\n    initHwDone = false;\r\n}\r\n\r\nCCS811_status CCS811_Init_Hw(void)\r\n{\r\n    uint8_t data[4] = {0x11,0xE5,0x72,0x8A}; /* reset key */\r\n    uint8_t status;\r\n    uint8_t val = 0;\r\n    CCS811_status error_status = CCS811_SUCCESS;\r\n\r\n    if (!initDriverDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* trick to allow calling internal public functions */\r\n    initHwDone = true;\r\n\r\n    /* check HW ID */\r\n    if (CCS811_readRegister( CCS811_HW_ID,  &val) != 0)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (val != 0x81)\r\n    {\r\n        error_status = CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* reset the device */\r\n    if (CCS811_multiWriteRegister(CCS811_SW_RESET, data, 4)!=0)\r\n    {\r\n        error_status =  CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    FCT_CCS811.WaitMsec(10);\r\n\r\n    if (CCS811_checkForStatusError(&status) == CCS811_I2C_ERROR)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (status == true) return CCS811_INTERNAL_ERROR;\r\n\r\n    error_status = CCS811_appValid(&val);\r\n    if (error_status != CCS811_SUCCESS) goto return_status;\r\n    if (val == 0)\r\n    {\r\n        error_status =  CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* write 0 byte to this register to start app */\r\n    //if (CCS811_writeRegister(CCS811_APP_START, 0)!=0) return CCS811_I2C_ERROR;\r\n    val = CCS811_APP_START;\r\n    if (FCT_CCS811.I2C_Write(&val, 1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* read every second */\r\n    if (CCS811_setDriveMode(1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    return_status:\r\n    if (error_status != CCS811_SUCCESS) initHwDone = false;\r\n    return error_status;\r\n}\r\n\r\nCCS811_status CCS811_readAlgorithmResults(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_ALG_RESULT_DATA, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    /* data ordered: co2MSB, co2LSB, tvocMSB, tvocLSB */\r\n    CO2 = ((uint16_t)data[0] << 8) | data[1];\r\n    tVOC = ((uint16_t)data[2] << 8) | data[3];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(StatusError != NULL);\r\n\r\n    /* read the status bit */\r\n    if (CCS811_readRegister(CCS811_STATUS, StatusError )!=0) return CCS811_I2C_ERROR;\r\n    *StatusError = *StatusError & 1 << 0; // bit ERROR\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_dataAvailable(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 3)>>3; // bit DATA_READY\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_appValid(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 4)>>4; // bit APP_VALID\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    *value=0xFF;\r\n    if (CCS811_readRegister(CCS811_ERROR_ID, value )!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(baseline != NULL);\r\n\r\n    uint8_t data[2];\r\n    if (CCS811_multiReadRegister(CCS811_BASELINE,data, 2)!=0) return CCS811_I2C_ERROR;\r\n\r\n    *baseline = ((uint16_t)data[0] << 8) | data[1];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setBaseline(uint16_t input)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[2];\r\n    data[0] = (input >> 8) & 0x00FF;\r\n    data[1] = input & 0x00FF;\r\n\r\n    if (CCS811_multiWriteRegister(CCS811_BASELINE, data, 2)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setInterrupts(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_INTERRUPT_DRIVEN); /* clear INTERRUPT bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_INTERRUPT_DRIVEN); /* set INTERRUPT bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setThresholds(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_THRESHOLDS_ENABLED); /* clear THRESHOLDS bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_THRESHOLDS_ENABLED); /* set THRESHOLDS bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setDriveMode(uint8_t mode)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    if (mode > 4) mode = 4; /* sanitize input */\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value)!=0) return CCS811_I2C_ERROR;\r\n    value &= ~(0b00000111 << 4); /* clear DRIVE_MODE bits */\r\n    value |= (mode << 4); /* mask in mode */\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* check for invalid temperatures */\r\n    if ((temperature < -25) || (temperature > 50)) return CCS811_GENERIC_ERROR;\r\n\r\n    /* check for invalid humidity */\r\n    if ((relativeHumidity < 0) || (relativeHumidity > 100)) return CCS811_GENERIC_ERROR;\r\n\r\n    uint32_t rH = relativeHumidity * 1000; /* 42.348 becomes 42348 */\r\n    uint32_t temp = temperature * 1000; /* 23.2 becomes 23200 */\r\n\r\n    uint8_t envData[4];\r\n\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;\r\n    envData[1] = 0; /* support only increments of 0.5 so bits 7-0 will always be zero */\r\n    if (((rH % 1000) / 100) > 2 && (((rH % 1000) / 100) < 8))\r\n    {\r\n        envData[0] |= 1; /* set 9th bit of fractional to indicate 0.5% */\r\n    }\r\n\r\n    temp += 25000; /* add the 25C offset */\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;\r\n    envData[3] = 0;\r\n    if (((temp % 1000) / 100) > 2 && (((temp % 1000) / 100) < 8))\r\n    {\r\n        envData[2] |= 1;  /* set 9th bit of fractional to indicate 0.5C */\r\n    }\r\n    if (CCS811_multiWriteRegister(CCS811_ENV_DATA, envData, 4)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nvoid CCS811_setRefResistance(float input)\r\n{\r\n    refResistance = input;\r\n}\r\n\r\nCCS811_status CCS811_readNTC(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_NTC, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    vrefCounts = ((uint16_t)data[0] << 8) | data[1];\r\n    ntcCounts = ((uint16_t)data[2] << 8) | data[3];\r\n    resistance = ((float)ntcCounts * refResistance / (float)vrefCounts);\r\n\r\n    temperature = log((long)resistance);\r\n    temperature = 1 / (0.001129148 + (0.000234125 * temperature) + (0.0000000876741 * temperature * temperature * temperature));\r\n    temperature = temperature - 273.15;  /* convert from Kelvin to Celsius */\r\n\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nuint16_t CCS811_getTVOC(void)\r\n{\r\n    return tVOC;\r\n}\r\n\r\nuint16_t CCS811_getCO2(void)\r\n{\r\n    return CO2;\r\n}\r\n\r\nfloat CCS811_getResistance(void)\r\n{\r\n    return resistance;\r\n}\r\n\r\nfloat CCS811_getTemperature(void)\r\n{\r\n    return temperature;\r\n}\r\n\r\n"
              }
            }
          }
        }
      },
      "drivers": {
        "adc": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_ADC_ADC1"
          }
        ],
        "ble": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLE_BLE1"
          }
        ],
        "block": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLOCK_BLOCK1"
          }
        ],
        "datetime": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_DATETIME_DATETIME1"
          }
        ],
        "filesytem": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_FILESYSTEM_FILESYSTEM1"
          }
        ],
        "gpio": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_GPIO_GPIO1"
          }
        ],
        "http": [],
        "i2c": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_I2C_I2C1",
            "primary": true
          },
          {
            "id": 1,
            "name": "ATMO_DRIVERINSTANCE_I2C_I2C2"
          }
        ],
        "interval": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1"
          }
        ],
        "nfc": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_NFC_NFC1"
          }
        ],
        "pwm": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_PWM_PWM1"
          }
        ],
        "spi": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_SPI_SPI1"
          }
        ],
        "uart": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_UART_UART1"
          },
          {
            "id": 1,
            "name": "ATMO_DRIVERINSTANCE_UART_UART2"
          },
          {
            "id": 2,
            "name": "ATMO_DRIVERINSTANCE_UART_UART3"
          },
          {
            "id": 3,
            "name": "ATMO_DRIVERINSTANCE_UART_UART4",
            "primary": true
          }
        ],
        "wifi": []
      },
      "static": {
        "header": "",
        "footer": "",
        "functions": {
          "ATMO_Setup": {
            "returnType": "void",
            "code": "\n",
            "arguments": []
          }
        }
      }
    },
    "App View": {
      "type": "app",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {
        "appViewLayouts": {
          "360": {
            "640": true
          },
          "411": {
            "731": true
          },
          "768": {
            "1024": true
          },
          "1024": {
            "768": true
          }
        }
      },
      "elements": [
        {
          "name": "CO2Label",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 132,
                  "y": 432,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "411": {
                "731": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "editorX": 452,
            "editorY": 491,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AirQualityLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 130,
                  "y": 240,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "411": {
                "731": {
                  "width": 100,
                  "height": 100,
                  "x": 255,
                  "y": 633,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 352,
                  "y": 720,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 560,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 451,
            "editorY": 238
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AppUIImage1",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 114,
                  "y": 222,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "411": {
                "731": {
                  "width": 100,
                  "height": 100,
                  "x": 238,
                  "y": 521.3709677419355,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 334,
                  "y": 588.3064516129032,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 448,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 741,
            "editorY": 407
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 114,
                  "y": 414,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "411": {
                "731": {
                  "width": 100,
                  "height": 100,
                  "x": 238,
                  "y": 623.3709677419355,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 334,
                  "y": 708.3064516129032,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 548,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 738,
            "editorY": 306
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppInterval",
          "type": "AppInterval",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null,
            "time": 1000,
            "startOnInitialize": true
          },
          "meta": {
            "editorX": 77,
            "editorY": 292,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQualityCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CO2Characteristic",
                "targetAbility": "read"
              }
            ],
            "started": [],
            "paused": []
          }
        },
        {
          "name": "AirQualityCloudData",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 452,
            "editorY": 93,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "AirQualityCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), ATMO_PROPERTY(AirQualityCharacteristic, readDataType), ATMO_PROPERTY(AirQualityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AirQualityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AirQualityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": true,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e75-a4ff-6f0cd50005f9",
            "read": true,
            "write": true,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 296,
            "editorY": 166,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "AirQualityCloudData",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "text": {
                    "code": "readData + \" ppb\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "AirQualityLabel",
                "targetAbility": "setText"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "AirQualityCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "CO2Characteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\t&ATMO_VARIABLE(CO2Characteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(CO2Characteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(CO2Characteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(CO2Characteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(CO2Characteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(CO2Characteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(CO2Characteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(CO2Characteristic, writeDataType), ATMO_PROPERTY(CO2Characteristic, readDataType), ATMO_PROPERTY(CO2Characteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\t&ATMO_VARIABLE(CO2Characteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(CO2Characteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(CO2Characteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\tATMO_VARIABLE(CO2Characteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(CO2Characteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(CO2Characteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(CO2Characteristic, instance),\n\t\tATMO_VARIABLE(CO2Characteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(CO2Characteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "0fa3c9f1-96a2-4d4c-b149-8d764a904a8f",
            "bleCharacteristicUuid": "0fa3c9f1-96a2-4d4c-b149-8d764a904a90",
            "read": true,
            "write": true,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 302,
            "editorY": 416,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "readData + \" ppm\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "CO2Label",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CO2CloudData",
                "targetAbility": "send"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "CO2Characteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "CO2CloudData",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 458,
            "editorY": 352,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "CO2Color",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 132,
                  "y": 342,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "411": {
                "731": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "CO2",
            "font": "18px Helvetica",
            "color": "black",
            "alignment": "center"
          },
          "meta": {
            "editorX": 552,
            "editorY": 437,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AirQualityColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 80,
                  "y": 90,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "411": {
                "731": {
                  "width": 200,
                  "height": 100,
                  "x": 34,
                  "y": 612,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "768": {
                "1024": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 680,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 520,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDEwPC90aXRsZT48Y2lyY2xlIGN4PSI1NSIgY3k9IjUyLjUiIHI9IjM1LjcxNCIgc3R5bGU9ImZpbGw6IzczODViZiIvPjxwYXRoIGQ9Ik01NSwxMDIuNWE1MCw1MCwwLDEsMSw1MC01MEE1MC4wNTcsNTAuMDU3LDAsMCwxLDU1LDEwMi41Wk01NSw0LjI4NkE0OC4yMTQsNDguMjE0LDAsMSwwLDEwMy4yMTQsNTIuNSw0OC4yNjgsNDguMjY4LDAsMCwwLDU1LDQuMjg2WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik00MS45NzksMzAuMTc5YTIuNzksMi43OSwwLDAsMC0yLjc5LDIuNzl2MTAuN2EyNS45LDI1LjksMCwwLDAtNi41MS0xLjR2MS44NmEyNi44LDI2LjgsMCwwLDEsNi41MSwxLjQ4M3Y1LjQ5M2EyNS44NTMsMjUuODUzLDAsMCwwLTYuNTEtMS4zOTV2MS44NmEyNi43ODQsMjYuNzg0LDAsMCwxLDYuNTEsMS40ODJ2NS40OTNhMjUuOSwyNS45LDAsMCwwLTYuNTEtMS40djEuODZhMjYuOCwyNi44LDAsMCwxLDYuNTEsMS40ODNWNzIuMDMxYTIuNzksMi43OSwwLDAsMCwyLjc5LDIuNzlINjguMDIxYTIuNzksMi43OSwwLDAsMCwyLjc5LTIuNzlWNjMuMjgzbC0xLjg2LS41NTJ2OS4zYS45My45MywwLDAsMS0uOTMuOTNINDEuOTc5YS45My45MywwLDAsMS0uOTMtLjkzVjMyLjk2OWEuOTMuOTMsMCwwLDEsLjkzLS45M0g2OC4wMjFhLjkzLjkzLDAsMCwxLC45My45M1Y0My45ODRhMjguNDc0LDI4LjQ3NCwwLDAsMC03LjQ0MS0xLjcxNWMtMi4wNDUsMC00LjU1NSwxLjAxOC02Ljk3NSwxLjk0OC0yLjIzMS44MzUtNC40NjUsMS43NzMtNi4wNDUsMS43NzNhMjQuNTU0LDI0LjU1NCwwLDAsMS01LjU4MS0xLjIyMXYxLjU2N2EyMi4zODcsMjIuMzg3LDAsMCwwLDUuNTgxLDEuMTA1YzEuOTU0LDAsNC4yNjUtLjkzLDYuNjg0LTEuODYsMi4yMzEtLjkzMSw0LjU3MS0xLjg2MSw2LjMzNi0xLjg2MXM0LjczMS45Myw3LjYxNSwxLjg2MWMzLjE2MS45Myw2LjE1MSwxLjg2LDguMiwxLjg2VjQ1Ljk5YTMwLjAxNCwzMC4wMTQsMCwwLDEtNi41MS0xLjQ1NFYzMi45NjlhMi43OSwyLjc5LDAsMCwwLTIuNzktMi43OVpNNjEuNTEsNDkuM2MtMi4wNDUsMC00LjU1NSwxLjAxNy02Ljk3NSwxLjk0Ny0yLjIzMS44MzYtNC40NjUsMS43NzMtNi4wNDUsMS43NzNBMjQuNSwyNC41LDAsMCwxLDQyLjkwOSw1MS44djEuOTc3YTIyLjQyNCwyMi40MjQsMCwwLDAsNS41ODEsMS4xYzEuOTU0LDAsNC4yNjUtLjkzLDYuNjg0LTEuODYsMi4yMzEtLjkzLDQuNTcxLTEuODYsNi4zMzYtMS44NnM0LjczMS45Myw3LjYxNSwxLjg2YzMuMTYxLjkzLDYuMTUxLDEuODYsOC4yLDEuODZ2LTEuODZjLTEuNjc0LDAtNC43My0uOTM3LTcuNjE0LTEuNzczQzY2LjU0Niw1MC4yMjQsNjMuNTU2LDQ5LjMsNjEuNTEsNDkuM1ptMCw3LjQ0Yy0yLjA0NSwwLTQuNTU1LDEuMDE4LTYuOTc1LDEuOTQ4LTIuMjMxLjgzNS00LjQ2NSwxLjc3My02LjA0NSwxLjc3M2EyNC41NTQsMjQuNTU0LDAsMCwxLTUuNTgxLTEuMjIxdjEuOTc2YTIyLjQzMywyMi40MzMsMCwwLDAsNS41ODEsMS4xMDVjMS45NTQsMCw0LjI2NS0uOTMsNi42ODQtMS44NiwyLjIzMS0uOTMxLDQuNTcxLTEuODYxLDYuMzM2LTEuODYxLDIuMjMxLDAsNS4wMSwxLjAyNSw3LjYxNSwxLjg2MSwzLjE2MS45Myw2LjE1MSwxLjg2LDguMiwxLjg2di0xLjg2Yy0xLjY3NCwwLTQuNzMtLjkzOC03LjYxNC0xLjc3M0M2Ni41NDYsNTcuNjY0LDYzLjU1Niw1Ni43NDEsNjEuNTEsNTYuNzQxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xMjkuNSw0OC43NjdhOC4zMzMsOC4zMzMsMCwwLDEsNS45NTItMi4zYzQuNDE1LDAsNi4yNzIsMi4xMTIsNi4yNzIsNi4zMzZ2Ni40MzFhMTYuNjEzLDE2LjYxMywwLDAsMCwuMjIzLDIuNTkyaC0yLjRhMTAuNzA5LDEwLjcwOSwwLDAsMS0uMTYtMi4yNGgtLjA2NWE1LjY2MSw1LjY2MSwwLDAsMS00LjkyNywyLjYyNGMtMy4wMzksMC01LjU2OC0xLjUzNi01LjU2OC00LjQ0NywwLTQuOTYsNS43Ni01LjI0OCw5LjQ0LTUuMjQ4aC45NnYtLjQ0OGMwLTIuMTc2LTEuMzc2LTMuMjk1LTMuNzEyLTMuMjk1YTYuNjUsNi42NSwwLDAsMC00LjQ0OSwxLjYzMVptNy4yMzIsNS44NTVjLTMuMTY4LDAtNS4yMTUuODYzLTUuMjE1LDIuODgsMCwxLjg4OCwxLjQwNywyLjU5MiwzLjI5NSwyLjU5MiwyLjg3OSwwLDQuMzUxLTIuMDgsNC40MTYtNC41MTJ2LS45NloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTQ3Ljc3LDM5LjE2N2ExLjgyMywxLjgyMywwLDAsMSwxLjgyMywxLjgyNCwxLjgyNCwxLjgyNCwwLDAsMS0zLjY0OCwwQTEuODIzLDEuODIzLDAsMCwxLDE0Ny43NywzOS4xNjdabS0xLjI0OSw3LjY4aDIuNVY2MS44MjFoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTUzLjk3Nyw1MC40YzAtMS4zNzYtLjEyOC0yLjU2LS4xMjgtMy41NTFoMi4zNjhjMCwuOC4wNjQsMS42MzIuMDY0LDIuNDY0aC4wNjRhNS40MzYsNS40MzYsMCwwLDEsNC45OTEtMi44NDksMi45NjUsMi45NjUsMCwwLDEsMS4wMjQuMTZsLS4xNiwyLjUyOGE0LjcsNC43LDAsMCwwLTEuMzQ0LS4xOTJjLTMuMDQsMC00LjM4MywyLjE0NS00LjM4Myw1LjU2N3Y3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTg5LjA3OSw2OS4xMTdoLTIuNVY1OS42NDZoLS4wNjRhNi45NDUsNi45NDUsMCwwLDEtNS4zNzUsMi41NTksNy41NDMsNy41NDMsMCwwLDEtNy44NzMtNy44NzEsNy41Nyw3LjU3LDAsMCwxLDcuNDg4LTcuODcyLDYuNDg5LDYuNDg5LDAsMCwxLDUuNzYsMy4wNGguMDY0VjQ2Ljg0N2gyLjVabS03LjgwOC0yMC4zNWE1LjIyNiw1LjIyNiwwLDAsMC01LjMxLDUuNTY3LDUuMzE3LDUuMzE3LDAsMSwwLDEwLjYyMywwQTUuMjI3LDUuMjI3LDAsMCwwLDE4MS4yNzEsNDguNzY3WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMDYuNzQzLDU4LjI3YzAsMS4zNzYuMTI4LDIuNTU5LjEyOCwzLjU1MUgyMDQuNWMwLS44LS4wNjUtMS42MzItLjA2NS0yLjQ2NGgtLjA2NGE1LjQzNiw1LjQzNiwwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDdoMi41djguOTkxYzAsMi41LDEuMDg3LDQuMDYzLDMuNDIzLDQuMDYzLDMuMjMzLDAsNC42NDEtMi4zMzYsNC42NDEtNS43NTl2LTcuM2gyLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIxMS4yODgsNDguNzY3YTguMzMzLDguMzMzLDAsMCwxLDUuOTUyLTIuM2M0LjQxNSwwLDYuMjcyLDIuMTEyLDYuMjcyLDYuMzM2djYuNDMxYTE2LjYxMywxNi42MTMsMCwwLDAsLjIyMywyLjU5MmgtMi40YTEwLjcwOSwxMC43MDksMCwwLDEtLjE2LTIuMjRoLS4wNjVhNS42NjEsNS42NjEsMCwwLDEtNC45MjcsMi42MjRjLTMuMDM5LDAtNS41NjgtMS41MzYtNS41NjgtNC40NDcsMC00Ljk2LDUuNzYtNS4yNDgsOS40NC01LjI0OGguOTZ2LS40NDhjMC0yLjE3Ni0xLjM3Ni0zLjI5NS0zLjcxMi0zLjI5NWE2LjY1LDYuNjUsMCwwLDAtNC40NDksMS42MzFabTcuMjMyLDUuODU1Yy0zLjE2OCwwLTUuMjE1Ljg2My01LjIxNSwyLjg4LDAsMS44ODgsMS40MDcsMi41OTIsMy4yOTUsMi41OTIsMi44NzksMCw0LjM1MS0yLjA4LDQuNDE2LTQuNTEydi0uOTZaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIyOC4zMTMsMzcuNjMxaDIuNXYyNC4xOWgtMi41WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMzcuMjQsMzkuMTY3YTEuODIyLDEuODIyLDAsMCwxLDEuODIzLDEuODI0LDEuODI0LDEuODI0LDAsMCwxLTMuNjQ3LDBBMS44MjMsMS44MjMsMCwwLDEsMjM3LjI0LDM5LjE2N1ptLTEuMjQ4LDcuNjhoMi41VjYxLjgyMWgtMi41WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yNTEuNjM5LDQ4Ljk1OGgtNC40MTZ2Ny40ODdjMCwxLjkyLjAzMywzLjQ1NiwyLjI0LDMuNDU2YTQuODcxLDQuODcxLDAsMCwwLDIuMjA4LS41MTFsLjEsMi4yNzFhNy41OTIsNy41OTIsMCwwLDEtMi45MTIuNTQ0Yy0zLjU1MiwwLTQuMTI3LTEuOTItNC4xMjctNS4wMjNWNDguOTU4aC0zLjI2NVY0Ni44NDdoMy4yNjVWNDIuNTkxaDIuNXY0LjI1Nmg0LjQxNloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjYwLjIxNSw2NS4yNDVjLS45OTIsMi41MjctMS45ODUsNC4yNTYtNC45OTIsNC4yNTZhNS40MjksNS40MjksMCwwLDEtMi4yNC0uMzg0bC4zMi0yLjE3N2E0LjgzNyw0LjgzNywwLDAsMCwxLjc2LjI1N2MxLjYzMiwwLDIuMjQtLjk5MiwyLjc4NC0yLjQ2NGwxLjAyNC0yLjgxNi02LjIwOC0xNS4wN2gyLjkxMmw0LjY0LDExLjc0M2guMDY0bDQuNDQ4LTExLjc0M2gyLjcxOVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48L3N2Zz4=",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 553,
            "editorY": 192
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        }
      ]
    },
    "Cloud": {
      "type": "cloud",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {},
      "elements": [
        {
          "name": "AirQualityCloudData",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 99,
            "editorY": 440,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "{AirQuality:value}"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              },
              {
                "mapping": {
                  "value": {
                    "code": "value > 500"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "TVOCHigh",
                "targetAbility": "check"
              }
            ]
          },
          "coupledElementName": "AirQualityCloudData",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "SensorData",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 502,
            "editorY": 341,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "CloudMeta",
          "type": "CloudMeta",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 752,
            "editorY": 90,
            "lastTrigger": "trigged"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LightsOn",
          "type": "CloudCondition",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 552,
            "editorY": 43,
            "lastTrigger": "conditionTrue"
          },
          "triggers": {
            "triggered": [],
            "conditionTrue": [
              {
                "mapping": {
                  "tag": {
                    "code": "\"lights\""
                  },
                  "value": {
                    "code": "\"on\""
                  }
                },
                "targetOrder": [
                  "tag",
                  "value"
                ],
                "targetElement": "CloudMeta",
                "targetAbility": "setValue"
              }
            ],
            "conditionFalse": [
              {
                "mapping": {
                  "tag": {
                    "code": "\"lights\""
                  },
                  "value": {
                    "code": "\"off\""
                  }
                },
                "targetOrder": [
                  "tag",
                  "value"
                ],
                "targetElement": "CloudMeta",
                "targetAbility": "setValue"
              }
            ]
          }
        },
        {
          "name": "CloudRegister",
          "type": "CloudRegister",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 551,
            "editorY": 141,
            "lastTrigger": "registered"
          },
          "triggers": {
            "triggered": [],
            "registered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CloudMeta",
                "targetAbility": "setStatusGood"
              }
            ]
          }
        },
        {
          "name": "TVOCHigh",
          "type": "CloudCondition",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 501,
            "editorY": 439,
            "lastTrigger": "conditionTrue"
          },
          "triggers": {
            "triggered": [],
            "conditionTrue": [
              {
                "mapping": {
                  "message": {
                    "code": "\"Air qua;ity warning\""
                  },
                  "conditions": {
                    "code": "{alarming:active}"
                  }
                },
                "targetOrder": [
                  "message",
                  "conditions"
                ],
                "targetElement": "TVOCHig",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "tag": {
                    "code": "\"AirQuality\""
                  },
                  "value": {
                    "code": "\"bad\""
                  }
                },
                "targetOrder": [
                  "tag",
                  "value"
                ],
                "targetElement": "AirQuality",
                "targetAbility": "setValue"
              }
            ],
            "conditionFalse": []
          }
        },
        {
          "name": "TVOCHig",
          "type": "CloudNotification",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 651,
            "editorY": 442,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AirQuality",
          "type": "CloudMeta",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 651,
            "editorY": 341,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "CloudRegister1",
          "type": "CloudRegister",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 503,
            "editorY": 239,
            "lastTrigger": "registered"
          },
          "triggers": {
            "triggered": [],
            "registered": [
              {
                "mapping": {
                  "values": {
                    "code": "\"active\""
                  }
                },
                "targetOrder": [
                  "values"
                ],
                "targetElement": "AirQuality",
                "targetAbility": "setAlarming"
              }
            ]
          }
        },
        {
          "name": "CO2CloudData",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 98,
            "editorY": 340,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "{CO2:value}"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "CO2CloudData",
          "coupledElementPlaneName": "App View"
        }
      ],
      "layout": {
        "height": 1000,
        "width": 1000,
        "zIndexOrder": []
      }
    }
  }
}